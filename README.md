# Brand Experience

- 브랜드가 고객을 만나는 모든 활동, 경험
- Brand, Experience, Design을 하나라 통합한 의미
- 기업의 브랜드를 소비자들이 경험할 수 있도록 디자인하고 기획하는 것을 의미
- 조금 더 쉽게 설명하자면, 기업들은 고유의 브랜드를 가지고 있다. 소비자는 기업의 브랜드를 다양한 채널, 접점을 통하여 경험을 한다. 예를들어, 회사의 로고를 반복적으로 접하거나, 기업의 제품을 구매하기 위해 홈페이지에 들어가거나, 광고를 통해서 접할 수도 있다. -> 소비자는 기업을 경험할 수 있는 다양한 접점과 지속적으로 마주하게 됩니다.
- 기업에서 추구하는 브랜드의 목표와 가치를 다양한 미디어의 마케팅접점에서 사용자들에게 정확히 전달 할 수 있는 경험을 기획하고 이를 위한 최적을 디자인을 하는 것
- 브랜드 경험이 중요한 이유는 소비자들에게 호감과 애착을 형성하고, 그들이 기업이 바라는 대로 이끌 수 있다는 점
  - 소비자들은 기업이 표방하는 가치를 원하여 브랜드를 구매하게 된다.
- 최근의 추세는 브랜드 경험이라는 분야를 선호하는 상황. 기업의 고유한 가치를 소비자들도 인식하게 됌. 또한, 단지 '제품을 구매한다'는 측면에서 벗어나 소비자들이 기업이 추구하는 '가치를 구매한다'는 성향을 갖게 된 것. 가치를 구매하기 때문에 자신이 추구하는 가치와 부합되는 브랜드를 구매하고 선호하는 현상이 확산됨
- 브랜드 경험이 다양한 매체를 통해 이루어지기 때문에, 모든 매체에서 일관된 모습을 드러나야 한다. 하나의 방향성과 일관된 형태를 통해 소비자에게 혼란의 여지 없는 정확한 브랜드 경험을 심어줄 수 있다. 또한, 소비자 뿐만 아니라 기업 내부 직원들에게까지 일관된 브랜드 경험을 제공해주어, '하나의 브랜드 경험, 브랜드 가치'를 전달하는 것.





# Hash Table

## Hash Table 동작 과정

1. Key -> Hash Function -> 결과 = Hash
2. Hash를 배열의 Index로 사용
3. 해당 Index에 Value 저장



## Hash 충돌

1. 서로 다른 key가 Hash Function에서 중복 Hash로 나오는 경우
2. 충돌이 많아질수록 탐색의 시간 복잡도가 O(1)에서 O(n)으로 증가

### Hash 충돌 해결 방법

1. Seperating Chaining
   - JDK 내부에서 사용하는 충돌 처리 방식
   - Linked List로 Hash값이 같은 Value 값 연결
2. Open addressing
   - 추가 메모리 공간을 사용하지 않고, Hash Table 배열의 빈 공간을 사용하는 방법
3. Resizing
   - 저장 공간이 일정 수3준 채워지면 Seperating Chaining의 경우 성능 향상을 위해 Open addressing의 경우 배열 크기 확장을 위해 Resizing
   - 보토 2배로 확장



## Hash Table의 장점

1. 작은 리소스로 많은 데이터를 효율적으로 관리 가능
2. 배열의 인덱스를 사용하기 때문에 빠른 검색, 삽입, 삭제 O(1)
3. Key와 Hash에 연관성이 없어 보안에 유리
4. 중복 제거 유용

## Hash Table의 단점

1. 충돌 발생 가능성
2. 공간 복잡도 무시
3. 순서 무시
4. 해시 함수에 의존



## Hash Table vs Hash Map

- Hash Table
  - 비동기 (단일 스레드)에서 사용
  - null 값 허용
- Hash Map
  - 동기 (멀티 스레드)에서 사용
  - null 값 미허용





# Stack

- LIFO
- 재귀 알고리즘
- 웹 브라우저 방문기록
- 실행 취소
- 역순 문자열 만들기
- 수식의 괄호 검사 (VPS, Valid Parenthesis String)
- 후휘 표기법 검사

# Queue

- FIFO
- BFS 구현
- 캐시 구현
- 우선순위가 같은 작업 예약 (인쇄 대기열)
- 선입선출이 필요한 대기역 (티켓 카운터)
- 콜센터 고객 대기시간
- 프린터의 출력 처리
- 프로세스 관리



---



# Network

## OSI 7계층

- ISO에서 개발한 모델로, 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명
- 프로토콜을 기능별로 나눈 것

1. 물리 계층
   - 네트워크의 기본 네트워크 하드웨어 전송 기술을 이룬다.
   - 네크워크의 높은 수준의 기능의 논리 데이터 구조를 기초로 하는 필수 계층이다.
   - 전송 단위는 Bit이다.
2. 데이터 링크 계층
   - P2P 간 신뢰성 있는 전송을 보장하기 위한 계층으로 CRC 기반의 오류 제어와 흐름 제어가 필요하다.
   - 주소 값은 물리적으로 할당 받는데, 이는 네트워크 카드가 만들어질 때부터 맥 주소가 정해져 있다는 뜻이다.
   - 데이터 링크 계층의 대표적 예는 이더넷이다.
   - 전송 단위는 Frame이다.
3. 네트워크 계층
   - 여러개의 노드를 거칠때마다 경로를 찾아주는 역할 하는 계층으로 다양한 길이의 데이터를 네트워크들을 통해 전달하고, 그 과정에서 전송 계층이 요구하는 서비스 품질(QoS)를 제공하기 위한 기능적, 절차적 수단을 제공한다.
   - 네트워크 계층은 라우팅, 흐름 제어, 세그멘테이션, 오류 제어 등을 수행한다.
   - 논리적인 주소 구조(IP), 곧 네트워크 관리자가 직접 주소를 할당하는 구조를 가지며, 계층적이다.
   - 데이터 전송 단위는 Datagram(Packet)이다.
4. 전송 계층
   - E2E의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해 주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다.
   - 시퀀스 넘버 기반의 오류 제어 방식을 사용한다.
   - 전송 계층이 패킷들의 전송이 유효한지 확인하고 전송 실패한 패킷들을 다시 전송한다.
   - 가장 잘 알려진 전송 계층의 예는 TCP이다.
   - 전송 단위는 Segment이다.
5. 세션 계층
   - 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.
   - Duplex, half-duplex, full-duplex의 통신과 함께, 체크 포인팅과 유휴, 종료, 다시 시작 과정 등을 수행한다.
   - 이 계층은 TCP/IP 세션을 만들고 없애는 역할을 한다.
6. 표현 계층
   - 코드 간의 번역을 담당, 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어 준다.
   - 인코딩이나 암호화 등의 동작이 이 계층에서 이루어진다.
7. 응용 계층
   - 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.



## TCP와 UDP

- 네트워크 계층 중 전송 계층에서 사용하는 프로토콜

### TCP

- 인터넷 상에서 데이터를 메세지의 형태(세그먼트 라는 블록 단위)로 보내기 위해 IP와 함께 사용하는 프로토콜이다.
- TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리한다.
- 연결형 서비스로 가상 회선 방식을 제공한다.
  - 3-way handshaking 과정을 통해 연결을 설정하고, 4-way handshaking을 통해 연결을 해제한다.
- 흐름 제어 및 혼잡제어를 제공한다.
  - 흐름제어
    - 데이터를 보내는 곳과 받는 곳의 데이터 처리 속도를 조절하여 받는 곳의 버퍼 오버플로우를 방지하는 것
  - 혼잡제어
    - 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것
    - 정보의 소통량이 과다하면 패킷을 조금만 전송하여 혼잡 붕괴 현상이 일어나는 것을 막는다.
  - 높은 신뢰성을 보장한다.
  - UDP보다 속도가 느리다.
  - Full-Duplex, Point-to-Point 방식이다.
    - Full-Duplex
      - 전송이 양방향으로 동시에 일어날 수 있다.
    - Point-to-Point
      - 각 연결이 정확히 2개의 종단점을 가지고 있다.
    - 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.
  - 연속성보다 신뢰성 있는 전송이 중요할 때 사용

### UDP

- 데이터를 데이터 그램 단위로 처리하는 프로토콜이다.
- 비연결형 서비스로 데이터그램 방식을 제공한다.
  - 연결을 위해 할당되는 논리적인 경로가 없다.
  - 따라서, 각각의 패킷은 다른 경로로 전송되고, 각각의 패킷은 독릭접인 관계를 갖게 된다.
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
- UDP헤더에서 checksum 필드를 통해 최소한의 오류만 검출한다.
- 신뢰성이 낮다.
- TCP보다 속도가 빠르다.
- 신뢰성보다는 연속성이 중요한 서비스, 스트리밍에 사용된다.

### 참고

- UDP와 TCP는 각각 별도의 포트 주소 공간을 관리하므로 같은 포트 번호를 사용해도 무방하다. 즉, 두 프로토콜에서 동일한 포트 번호를 할당해도 서로 다른 포트로 간주한다.



### TCP의 3 way handshake 와 4 way handshake

- TCP는 장치들 사이에 논리적인 접ㅂ속을 성립하기 위하여 연결을 설정하여 신뢰성을 보장하는 연결형 서비스이다.

#### 3 way handshake

- TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정
- 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장, 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었다는 것을 알 수 있게 해준다.
- 즉, TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.
  - A 프로세스(Client)가 B 프로세스(Server)에 연결을 요청![3-way-handshaking](/Users/ryuseungmin/Desktop/dev사진/3-way-handshaking.png)
    - A -> B : SYN
      - 접속 요청 프로세스 A가 연결 요청 메시지 전송 (SYN)
      - 송신자가 최초로 데이터를 전송할 때 Sequence Number를 임의 랜덤 숫자로 지정하고, SYN 플래그 비트를 1로 설정한 세그먼트를 전송한다.
    - B -> A : SYN + ACK
      - 접속 요청을 받은 프로세스 B가 요청을 수락했으며, 접속 요청 프로세스인 A도 포트를 열어 달라는 메시지 전송 (SYN + ACK)
      - 수신자는 ACK# 필드를 Sequence# + 1로 지정하고, SYN과 ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
    - A -> B : ACK
      - 마지막으로 접속 요청 프로세스 A가 수량 확인을 보낸 연결을 맺음 (ACK)
      - 이때, 전송할 데이터가 있으면 이 단계에서 데이터를 전송할 수 있다.

#### 4 way handshake

- TCP의 연결을 해체하는 과정

  - A 프로세스(Client)가 B 프로세스(Server)에 연결 해제를 요청

    ![4-way-handshaking](/Users/ryuseungmin/Desktop/dev사진/4-way-handshaking.png)

  - A -> B: FIN

    - 프로세스 A가 연결을 종료하겠다는 FIN 플래그를 전송
    - 프로세스 B가 FIN 플래그로 응답하기 전까지 연결을 계속 유지

  - B -> A : ACK

    - 프로세스 B는 일단 확인 메시지를 보내고 자신의 통신이 끝날 때까지 기다린다.
    - 수신자는 ACK$ 필드를 Seq# + 1로 지정하고, ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
    - 그리고 자신이 전송할 데이터가 남아있다면 이어서 계속 전송한다.

  - B -> A : FIN

    - 프로세스 B가 통신이 끝났으면 연결 종료 요청에 합의한다는 의미로 프로세스 A에게 FIN 플래그를 전송

  - A -> B : ACK

    - 프로세스 A는 확인했다는 메시지를 전송

  #### TCP 관련 질문

  - TCP의 연결 설정 과정과 연결 종료 과정이 단계가 차이나는 이유?
    - 클라이언트가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 떄문이다.
  - 만약 서버에서 FIN 플래그를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?
    - 이러한 현상에 대비하여 클라이언트는 서버로부터 FIN 플래그를 수신하더라도 일정 시간동안 세션을 남겨 놓고 잉여 패킷을 기다리는 과정을 거친다.
  - 초기 Seq# 인 ISN을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유는?
    - 연결을 맺을 때 사용하는 포트는 유한 범위 내에서 사용하고, 시간이 지남에 따라 재사용 된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다. 서버 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 #가 전송된다면 이전의 연결로부터 오는 패킷으로 인식할 수 이있다. 이런 문제가 발생할 가능성을 줄이기 위해 난수를 설정한다.



### HTTP와 HTTPS

- HTTP 프로토콜
  - 개념
    - HyperText Transfer Protocol
    - 웹 상에서 클라이언트와 서버 간에 요청/응답으로 정보를 주고 받을 수 있는 프로토콜
  - 특징
    - 주로 HTML 문서를 주고 받는 데에 쓰인다.
    - TCP와 UDP를 사용하며, 80번 포트를 사용.
    - 비연결
      - 클라이언트가 요청을 서버에 보내고 서버가 적절한 응답을 클라이언트에 보내면 바로 연결이 끊긴다.
    - 무상태
      - 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다.
- HTTPS 프로토콜
  - 개념
    - HTTP over TLS, HTTP over SSL, HTTP Secure
    - 웹 통신 프로토콜인 HTTP의 보안이 강화된 버전의 프로토콜
  - 특징
    - HTTPS의 기본 TCP/IP 포트로 443번 포트를 사용한다.
    - HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에, 웹 상에서 정보를 암호화하는 SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화한다.
      - TLS(Transport Layer security) 프로토콜은 SSL(Secure Socket Layer) 프로토콜에서 발전한 것이다.
      - 두 프로토콜의 주요 목표는 기밀성, 데이터 무결성, ID 및 디지털 인증서를 사용한 인증을 제공하는 것이다.
    - 따라서 데이터의 적절한 보호를 보장한다.
      - 보호의 수준은 웹 브라우저에서의 구현 정확도와 서버 소프트웨어, 지원하는 암호화 알고리즘에 달려있다.
    - 금융 정보나 메일 등 중요한 정보를 주고받는 것은 HTTPS를, 아무나 봐도 상관없는 페이지는 HTTP를 사용한다.
- HTTPS가 필요한 이유
  - 클라이언트인 웹브라우저가 서버에 HTTP를 통해 웹 페이지나 이미 정보를 요청하면 서버는 이 요청에 응답하여 요구하는 정보를 제공하게 된다.
  - 웹 페이지(HTML)는 텍스트이고, HTTP를 통해 이런 텍스트 정보를 교환하는 것이다.
  - 이때 주고받는 텍스트 정보에 주번이나 비번과 같이 민감한 정보가 포함된 상태에서 네트워크 상에서 중간에 제 3자가 정보를 가로챈다면 보안상 큰 문제가 발생한다.
  - 즉, 중간에서 정보를 볼 수 없도록 주고받는 정보를 암호화하는 방법인 HTTPS를 사용하는 것이다.
- HTTPS의 원리
  - 공개키 알고리즘 방 (비대칭키 암호화 방식)
    - 공개키와 개인키를 이용한 암호화 방식
  - 암호화, 복호화시킬 수 있는 서로 다른 키를 이용한 방법
    - 공개키 : 모두에게 공개, 공개키 저장소에 등록
    - 개인키 : 개인에게만 공개, 클라이언트-서버 구조에서는 서버가 가지고 있는 비공개키
  - 클라이언트 -> 서버
    - 사용자의 데이터를 공개키로 암호화 (공개키를 얻은 인증된 사용자)
    - 서버로 전송 (데이터를 가로채도 개인키가 없으므로 복호화할 수 없음)
    - 서버의 개인키를 통해 복호화하여 요청 처리
- HTTPS의 장단점
  - 장점
    - 네트워크 상에서 열람, 수정이 불가능하므로 안전하다.
  - 단점
    - 암호화를 하는 과정이 웹 서버에 부하를 준다.
    - HTTPS는 설치 및 인증서를 유지하는데 추가 비용이 발생한다.
    - HTTP에 비해 느리다.
    - 인터넷 연결이 끊긴 경우 재인증 시간이 소요된다.
      - HTTP는 비연결형으로 웹 페이지를 보는 중 인터넷 연결이 끊겼다가 다시 연결되어도 페이지를 계속 볼 수 있다.
      - 그러나 HTTPS의 경우에는 소켓(데이터를 주고 받는 경로) 자체에서 인증을 하기 때문에 인터넷 연결이 끊기면 소켓도 끊어져서 다시 HTTPS 인증이 필요하다.



### GET & POST

- HTTP 프로토콜을 이용해서 서버에 데이터를 전달할 때 사용하는 방식
- GET 방식
  - 개념
    - 정보를 조회하기 위한 메소드
    - 서버에서 어떤 데이터를 가져와서 보여주기 위한 용도의 메소드
    - 가져오는 것(Select)
  - 사용 방법
    - URL의 끝에 '?' 가 붙고, 요청 정보가 (key=value) 형태의 쌍을 이루어 ?뒤에 이어서 붙어 서버로 전송한다.
    - 전송하는 정보가 여러개일 경우에는 &로 구분한다.
    - e.g.) www.server.com?name1=value1&name2=value2
  - 특징
    - URL에 요청 정보를 붙여서 전송한다.
    - URL에 요청 정보가 이어붙기 때문에 길이 제한이 있어서 대용량의 데이터를 전송하기 어렵다.
    - 요청 정보를 사용자가 쉽게 눈으로 확인 가능하다.
    - HTTP 패킷의 Body는 비어 있는 상태로 전송한다.
    - POST 방식보다 빠르다.
      - GET 방식은 캐싱을 사용할 수 있어, GET 요청과 그에 대한 응답이 브라우저에 의해 캐쉬된다.
- POST 방식
  - 개념
    - 서버의 값이나 상태를 바꾸기 위한 용도의 메소드
    - 수행하는 것(Insert, Update, Delete)
  - 사용 방법
    - 요청 정보를 HTTP 패킷의 Body 안에 숨겨서 서버로 전송한다.
  - 특징
    - Body 안에 숨겨서 요청 정보를 전송하기 때문에 대용량의 데이터를 전송하기에 적합하다.
    - 클라이언트 쪽에서 데이터를 인코딩하여 서버로 전송하고, 이를 받은 서버 쪽이 해당 데이터를 디코딩한다.
    - GET 방식보다 보안상 안전하다.
- POST/GET 질문
  - 조회하기 위한 용도 POST가 아닌 GET 방식을 사용하는 이유?
    - 설계 원칙에 따라 GET 방식은 서버에게 여러 번 요청을 하더라도 동일한 응답이 돌아와야 한다.
      - GET 방식은 가져오는 것(Select)으로 서버의 데이터나 상태를 변경시키지 않아야 한다.
        - e.g.) 게시판 리스트, 글 보기
      - POST 방식은 수행하는 것으로, 서버의 값이나 상태를 바꾸기 위한 용도이다.
        - e.g.) 게시판에 글쓰기 기능
    - 웹에서 모든 리소스는 Link 할 수 있는 URL을 가지고 있어야한다.
      - 어떤 웹페이지를 보고 있을 때 다른 사람한테 그 주소를 주기 위해서 주소창의 URL을 복사해서 줄 수 있어야 한다.
      - 즉, 어떤 웹페이지를 조회할 때 원하는 페이지로 바로 이동하거나 이동시키기 위해서는 해당 링크의 정보가 필요하다.
      - 이때 POST 방식을 사용할 경우에 값(링크의 정보)이 Body에 있기 때문에 URL만 전달할 수 없으므로 GET 방식을 사용해야 한다. 그러나 글을 저장하는 경우에는 URL을 제공할 필요가 없기 때문에 POST 방식을 사용한다.



### 쿠키와 세션

- HTTP 프로토콜의 특징

  - 비연결 지향 
    - 클라이언트가 request를 서버에 보내고, 서버가 클라이언트에 요청에 맞는 response르 보내면 바로 연결을 끊는다.
  - 상태정보를 유지 안함
    - 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다.

- 쿠키와 세션의 필요성

  - HTTP 프로토콜은 위와 같은 특징으로 모든 요청 간 의존관계가 없다.
  - 즉, 현재 접속한 사용자가 이전에 접속했던 사용자와 같은 사용자인지 아닌지 알 수 있는 방법이 없다.
  - 계속해서 연결을 유지하지 않기 때문에 리소스 낭비가 줄어드는 것이 큰 장점이지만, 통신할 때마다 새로 연결하기 때문에 클라이언트는 매 요청마다 인증을 해야 한다는 단점이 있다.
  - 이전 요청과 현재 요청이 같은 사용자의 요청인지 알기 위해서는 상태를 유지해야 한다.
  - HTTP 프로토콜에서 상태를 유지하기 위한 기술로 쿠키와 세션이 있다.

- 쿠키(Cookie)란?

  - 개념

    - 클라이언트 로컬에 저장되는 키와 값이 들어있는 파일이다.
    - 이름, 값, 유효 시간, 경로 등을 포함하고 있다.
    - 클라리언트의 상태 정보를 브라우저에 저장하여 참조한다.

  - 동작 방식

    ![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/cookie-process.png)

    

    - 웹 브라우저가 서버에 요청
    - 상태를 유지하고 싶은 값을 쿠키로 생성
    - 서버가 응답할 때 HTTP 헤더에 쿠키를 포함해서 전송
    - 전달받은 쿠키는 웹브라우저에서 관리하고 있다가, 다음 요청 떄 쿠키를 HTTP 헤더에 넣어서 전송
    - 서버에서는 쿠키 정보를 읽어 이전 상태 정보를 확인하 후 응답

- 세션이란?

  - 개념

    - 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술이다.
    - 즉, 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태이다.

  - 동작 방식

    ![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/session-process.png)

    - 웹 브라우저가 서버에 요청
    - 서버가 해당 웹브라우저에 유일한 ID를 부여함
    - 서버가 응답할 때 HTTP 헤더에 세션 ID를 포함해서 전송, 쿠키에 세션 ID를 저장
    - 웹브라우저는 이후 웹브라우저를 닫기까지 다음 요청 때 부여된 세션 ID가 담겨있는 쿠키를 HTTP 헤더에 넣어서 전송
    - 서버는 세션 ID를 확인하고, 해당 세션에 관련된 정보를 확인한 후 응답

  - 세션 사용 예

    - 로그인

  - 세션도 쿠키를 사용하여 값을 주고받으며 클라이언트의 상태 정보를 유지한다. 즉, 상태 정보를 유지하는 수단은 쿠키 이다.

- 쿠키와 세션의 차이점

  - 저장 위치
    - 쿠키 : 클라이언트
    - 세션 : 서버
  - 보안
    - 쿠키 : 클라이언트에 저장되므로 보안에 취약하다.
    - 세션 : 쿠키를 이용해 세션 ID 만 저장하고 이 값으로 구분해서 서버에서 처리하므로 비교적 보안성이 좋다.
  - 라이프사이클
    - 쿠키 : 만료시간에 따라 브라우저를 종료해도 계속해서 남아 있을 수 있다.
    - 세션 : 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.
  - 속도
    - 쿠키 : 클라이언트에 저장되어서 서버에 요청 시 빠르다.
    - 세션 : 실제 저장된 정보가 서버에 있으므로 서버의 처리가 필요해 쿠키보다 느리다.







### REST와 RESTful의 개념

- REST란
  - REST의 정의
    - Representational State Transfer
    - www과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 개발 아키텍처의 한 형식
      - REST는 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일이다.
      - REST는 네트워크 상에서 클라이언트와 서버 사이의 통신 방식 중 하나이다.
  - REST의 구체적인 개념
    - HTTP URI(Uniform Resource Identifier)를 통해 자원을 명시하고, HTTP Method(Post, Get, Put, Delete)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.
      - 즉, REST는 자원 기반의 구조(ROA, Resource Oriented Architecture) 설계 중심에 Resource가 있고, HTTP 메소드를 통해 Resource를 처리하도록 설계된 아키텍처를 의미한다.
      - 웹 사이트의 이미지, 텍스트, DB 내용 등의 모든 자원에 고유한 ID인 HTTP URI를 부여한다.
  - REST 장단점
    - 장점
      - 여러 가지 서비스 디자인에서 생길 수 있는 문제를 최소화해준다.
      - Hypermedia API의 기본을 충실히 지키면서 범용성을 보장한다.
      - HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 해준다.
    - 단점
      - 브라우저를 통해 테스트할 일이 많은 서비스라면 쉽게 고칠 수 있는 URL보다 Header 값이 왠지 더 어렵게 느껴진다.
      - 구형 브라우저가 아직 제대로 지원해주지 못하는 부분이 존재한다.
        - PUT, DELETE를 사용하지 못하는 점
        - pushState를 지원하지 않는 점
  - REST가 필요한 이유
    - '애플리케이션 분리 및 통합'
    - '다양한 클라이언트의 등장'
    - 즉, 최근의 서버 프로그램은 다양한 브라우저와 안드로이드 폰, 아이폰과 같은 모바일 디바이스에서도 통신을 할 수 있어야 한다.
  - REST 구성 요소
    - 자원(Resource) : URI
      - 모든 자원에 고유한 ID가 존재하고, 이 자원은 Server에 존재한다.
        - 자원을 구별하는 ID는 '/groups/:group_id'와 같은 HTTP URI 다.
        - 클라이언트는 URI를 이용해서 자원을 지정하고 해당 자원의 상태에 대한 조작을 Server에 요청한다.
    - 행위 : HTTP Method
      - HTTP 프로토콜의 메소드를 사용한다
      - HTTP 프로토콜은 GET, POST, PUT, DELETE, HEAD 와 같은 메소드를 제공한다.
    - 표현
      - 클라이언트가 자원의 상태에 대한 조작을 요청하면 Server는 이에 적절한 응답을 보낸다.
      - REST에서 하나의 자원은 JSON, XML, TEXT 등 여러 형태의 표현으로 나타내어 질 수 있다.
      - JSON 혹은 XML를 통해 데이터를 주고 받는 것이 가장 일반적이다.
  - REST의 특징
    - 서버-클라이언트 구조
    - 무샅애
    - 캐시 처리 가능
    - 계층화
    - 인터페이스 일관성



### Socket.io와 WebSocket의 차이

- WebSocket
  - 개념
    - 웹 페이지의 한계에서 벗어나 실시간으로 상호작용하는 웹 서비스를 만드는 표준 기술
  - 배경
    - HTTP 프로토콜은 클라이언트에서 서버로의 단방향 통신을 위해 만들어진 방법이다.
    - 실시간 웹을 구현하기 위해서는 양방향 통신이 가능해야 하는데, WebSocket 이전에는 Polling, Streaming 방식의 AJAX 코드를 이용하여 구현
    - 하지만 이 방법들을 이용하면 각 브라우저마다 구현 방법이 달라 개발이 어렵다는 문제점 발생
    - 이를 위해 HTML5 표준의 일부로 WebSocket이 만들어지게 되었다.
  - 일반 TCP Socket과의 차이점
    - 일반 HTTP Request를 통해 handshaking 과정을 거쳐 최초 접속이 이뤄진다.
  - 특징
    - 소켓을 이용하여 자유롭게 데이터를 주고 받을 수 있다.
    - 기존의 요청-응답 관계 방식보다 더 쉽게 데이터를 교환할 수 있다.
    - 다른 HTTP Request와 마찬가지로 80포트를 통해 웹 서버에 연결한다.
    - http::// 대신 ws:// 로 시작하며 Streaming과 유사한 방식으로 푸쉬를 지원한다.
    - 클라이언트인 브라우저와 마찬가지로 웹 서버도 WebSocket 기능을 지원해야 한다.
    - WebSocket은 다가올 미래의 기술이지 아직 인터넷 기업에서 시범적으로라도 써 볼 수 있는 기술이 아니다.
  - 장점
    - HTTP Request를 그대로 사용하기 때문에 기존의 80, 443 포트로 접속을 하므로 추가로 방화벽을 열지 않고도 양방향 통신이 가능하다.
- Socket.io
  - 개념
    - 다양한 방식의 실시간 웹 기술을 손쉽게 사용할 수 있는 모듈 (웹 클라이언트의 푸쉬를 지원하는 모듈)
    - 즉, Socket.io는 JavaScript를 이용하여 브라우저 종류에 상관없이 실시간 웹을 구현할 수 있도록 한 기술
  - 특징
    - Socket.io는 현재 바로 사용할 수 있는 기술이다.
    - WebSocket 프로토콜은 IETF에서 관장한은 표준 프로토콜이라서 WebSocket을 지원하는 여러 서버 구현체가 있지만 Socket.io는 Node.js 뿐이다.
  - 장점
    - WebSocket을 지원하지 않는 어느 브라우저라도 푸쉬 메세지를 일관된 모듈로 보낼 수 있다.



![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/osi-pdu.png)







# Operating System

## 프로세스와 스레드의 차이

- ### 프로그램이란

  - 어떤 작업을 위해 실행할 수 있는 파일

- ### 프로세스란

  - 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램

    - 메모리에 올라와 실행되고 있는 프로그램의 인스턴스 (독립적인 개체)
    - 운영체제로부터 시스템 자원을 할당받는 작업의 단위
    - 즉, 동적인 개념으로는 실행된 프로그램을 의미한다.

  - 할당받는 시스템 자원의 예

    - CPU 시간
    - 운영되기 위해 필요한 주소 공간
    - Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역

  - 특징

    ![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/process.png)

  - 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당받는다.

  - 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있다.

  - 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.

  - 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신 IPC(Inter-Process-Communicantion)을 사용해야 한다. (e.g) 파이프, 파일, 소켓 등을 이용한 통신 방법 이용)

- ### 스레드란

  - 프로세스 내에서 실행되는 여러 흐름의 단위

    - 프로세스의 특정한 수행 경로
    - 프로세스가 할당받은 자원을 이용하는 실행의 단위

  - 특징

    ![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/thread.png)

    - 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다.
    - 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들을 같은 프로세스 내에서 스레드끼리 공유하면서 실행된다.
    - 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유한다. 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.
    - 각각의 스레드는 별도의 레지스터와 스택을 갖고 있ㄷ지만, 힙 메모리는 서로 읽고 쓸 수 있다.
    - 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드도 그 변경 결과를 즉시 볼 수 있다.

  - ### 자바 스레드란

    - 일반 스레드와 거의 차이가 없으며, JVM가 운영체제의 역할을 한다.
    - 자바에는 프로세스가 존재하지 않고 스레드만 존재하며, 자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록이다.
    - 자바에서 스레드 스케줄링은 전적으로 JVM에 의해 이루어진다.
    - 아래와 같은 스레드와 관련된 많은 정보들도 JVM에 의해 이루어진다.
      - 스레드가 몇 개 존재하는지
      - 스레드로 실행되는 포그램의 코드의 메모리 위치는 어디인지
      - 스레드의 상태는 무엇인지
      - 스레드 우선순위는 얼마인지
    - 즉, 개발자는 자바 스레드로 작동할 스레드 코드를 작성하고, 스레드 코드가 생명을 가지고 실행을 시작하도록 JVM에 요청하는 일 뿐이다.

- ### 멀티 프로세스 대신 멀티 스레드를 사용하는 이유

  - 쉽게 설명하자면, 프로그램을 여러 개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이다.

    ![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/multi-thread.png)

  - 자원의 효율성 증대

    - 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
      - 프로세스 간의 Context Switching (문맥 교환)시 단순히 CPU 레지스터 교체 뿐만 아니라 RAM과 CPU 사이의 캐시 메모리에 대한 데이터까지 초기화되므로 오버헤드가 크기 떄문
    - 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소마가 줄어들게 된다.

  - 처리 비용 감소 및 응답 시간 단축

    - 또한 프로세스 간의 통신(IPC)보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신의 부담이 줄어든다.
      - 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문
    - 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다.
      - 문맥 교환시 스레드는 Stack 영역만 처리하기 때문

  - <span style = "color : red">주의할 점!</span>

    - 동기화 문제
    - 스레드 간의 자원 공유는 전역 변수(데이터 세그먼트)를 이용하므로 함께 상용할 때 충돌이 발생할 수 있다.

- ### Thread-safe

  - #### Thread-safe란?

    - 멀티스레드 환경에서 여러 스레드가 동시에 하나의 객체 및 변수(공유 자원)에 접근할 때, 의도한 대로 동작하는 것을 말한다.
    - 이러한 상황을 "Thread-safe"라고 표현한다.

  - #### Thread-safe하게 구현하기

    - Thread-safe하기 위해서는 공유 자원에 접근하는 임계영역(critical section)을 동기화 기법으로 제어해줘야 한다.
      - 이를 Mutual exclusion (상호배제)라고 한다.
    - 동기화 기법으로는 Mutex나 Semaphore 등이 있다.

  - #### Reentrant

    - 재진입성의 의미로, 어떤 함수가 Reentrant하다는 것은 여러 스레드가 동시에 접근해도 언제나 같은 실행 결과를 보장하는 의미이다.
    - 이를 만족하기 위해서 해당 서브루틴에서는 공유자원을 사용하지 않으면 된다.
    - Reentrant -> Thread-safe하다.

- ### 동기화 객체의 종류

  - #### 스레드 동기화 방법

    - 실행 순서의 동기화
      - 스레드의 실행순서를 정의하고, 이 순서에 반드시 따르도록 하는 것
    - 메모리 접근에 대한 동기화
      - 메모리 접근에 있어서 동시접근을 막는 것
      - 실행의 순서가 중요한 상황이 아니고, 한 순간에 하나의 스레드만 접근하면 되는 상황을 의미

  - #### 동기화 기법의 종류

    - 유저 모드 동기화
      - 커널의 힘을 빌리지 않는 동기화 기법
      - 성능상 이점, 기능상의 제한
      - e.g) 크리티컬 섹션 기반의 동기화, 인터락 함수 기반의 동기화
    - 커널 모드 동기화
      - 커널에서 제공하는 동기화 기능을 활용하는 방법
      - 커널 모드로의 변경이 필요하고 이는 성능 저하로 이어짐, 다양한 기능 활용 기능
      - e.g) 뮤텍스 기반의 동기화, 세마포어 기반의 동기화, 이름있는 뮤텍스 기반의 프로세스 동기화, 이벤드 기반의 동기화

- ### 뮤텍스와 세마포어의 차이

  - #### 뮤텍스

    - 공유된 자원의 데이터를 <b>여러 스레드</b>가 접근하는 것을 막는 것
    - 상호배제라고도 하며, Critical Section을 가진 스레드의 Running time이 서로 겹치지 않도록 각각 단독으로 실행하게 하는 기술이다.
    - 다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 synchronized 또는 Lock 을 사용한다
      - 즉, 뮤텍스 객체를 두 스레드가 동시에 사용할 수 없다.

  - #### 세마포어

    - 공유된 자원의 데이터를 <b>여러 프로세스</b>가 접근하는 것을 막는 것
    - 리소스 상태를 나타내는 간단한 카운터로 생각할 수 있다.
      - OS 또는 커널의 한 지정된 저장장치 내의 값이다.
      - 일반적으로 비교적 긴 시간을 확보하는 리소스에 대해 이용한다.
      - 유닉스 시스템 프로그래밍에서 세마포어는 운영체제의 리소스를 경쟁적으로 사용하는 다중 프로세스에서 행동을 조정하거나 또는 동기화 시키는 기술이다.
    - 공유 리소스에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자가 접근하여 사용할 수 있다.
    - 각 프로세스는 세마포어 값을 확인하고 변경할 수 있다.
      - 사용 중이지 않는 자원 경우 그 프로세스가 즉시 자원을 사용할 수 있다.
      - 이미 다른 프로세스에 의해 사용 중이라는 사실을 알게 되면 재시도하기 전에 일정 시간을 기다려야 한다.
      - 세마포어를 사용하는 프로세스는 그 값을 확인하고, 자원을 사용하는 동안에는 그 값을 변경함으로써 다른 세마포어 사용자들이 기다리도록 해야한다.
      - 세마포어는 이진수를 사용하거나, 추가적인 값을 가질 수 있다.

  - #### 차이

    - 가장 큰 차이점은 관리하는 동기화 대상의 개수
      - 뮤텍스는 동기화 대상이 오직 하나뿐일 때, 세마포어는 동기화 대상이 하나 이상일 때 사용한다.
    - 세마포어 -> 뮤텍스 (o) , 뮤텍스 -> 세마포어(x)
    - 세마포어는 소유할 수 없는 반면, 뮤텍스는 소유가 가능하며 소유주가 이에 대한 책임을 가진다.
      - 뮤텍스의 경우 상태가 두개 뿐인 lock 이므로 lock 을 가질 수 있다.
    - 뮤텍스의 경우 뮤텍스를 소유하고 있는 스레드가 이 해제할 수 있다. 하지만 세마포어의 경우 이러한 세마포어를 소유하지 않는 스레드가 세마포어를 해제할 수 있다.
    - 세마포어는 시스템 범위에 걸쳐있고 파일 시스템상의 파일 형태로 존재하는 반면, 뮤텍스는 프로세스 범위를 가지며 프로세스가 종료될 때 자동으로 Clean Up 된다.

- ### 동기와 비동기

  - #### 동기란?

    - 두개의 프로세스가 데이터를 주고 받을 때, 주고 받는 순서(또는 시간)가 일정하는 것을 뜻한다.

  - #### 비동기란?

    - 동기가 아닌 것

  - #### 동기식, 동기적이다

    - 어떤 작업을 요청했을 때 그 작업이 종료될 때까지 기다린 후 다음 작업을 수행한다.
      - 데이터를 주고받는 '순서'가 중요할 때 사용된다.
      - 요청한 작업만 처리하면 되기 때문에 전체적인 수행 속도는 빠를 수 있다.
      - 한 작업에 대한 시간이 길어질 경우, 전체 응답이 지연될 수 있다.

  - #### 비동기식, 비동기적이다.

    - 어떤 작업을 요청했을 때 그 작업이 종료될 때까지 기다리지 않고, 다음 작업을 수행한다. 요청했던 작업이 끝나면 결과를 받고, 그에 따른 추가 작업이 있다면 수행한다.
      - 요청 순서에 상관없이, 동시에 다수의 작업을 처리할 수 있다.
      - 작업이 끝날 떄 따로 이벤트를 감지하고 결과를 받아 그에 따른 추가 작업을 해줘야하기 때문에, 비교적 느릴 수 있다.
      - I/O 작업이 잦고, 빠른 응답속도를 요구하는 프로그램에 적합하다.

- ### 교착상태의 개념과 조건

  - #### 교착상태(데드락)?

    - 첫 번째 스레드는 두 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리고 있고, 두 번째 스레드 역시 첫 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리고 있는 상황을 일컷는다.
    - 모든 스레드가 락이 풀리기를 기다리고 있기 때문에, 무한 대기 상태에 빠지게 된다. 이런 스레드를 교착상태에 빠졌다고 한다.

  - #### 교착상태의 4가지 조건

    - ##### 상호배제

      - 한 번에 한 프로세스만 공유 자원을 사용할 수 있다.
      - 좀 더 정확하게는, 공유 자원에 대한 접근 권한이 제한된다. 자원의 양이 제한되어 있더라도 교착상태는 발생할 수 있다.

    - ##### 점유 대기

      - 공유 자원에 대한 접근 권한을 갖고 있는 프로세스가 그 접근 권한을 양보하지 않은 상태에서 다른 자원에 대한 접근 권한을 요구할 수 있다.

    - ##### 비선점

      - 한 프로세스가 다른 프로세스의 자원 접근 권한을 강제로 취소할 수 없다

    - ##### 순환대기

      - 두 개 이상의 프로세스가 자원 접근을 기다리는데, 그 관계에 사이클이 존재한다.

  - #### 교착상태 방지

    - 4가지 조건들 가운데 하나를 제거하면 된다.
    - 공유 자원 중 많은 경우가 한 번에 한 프로세스만 사용할 수 있기 때문에 상호배제는 제거하기 어렵다.
    - 대부분의 교착상태 방지 알고리즘은 4번 조건, 즉 대기 상태의 사이클이 발생하는 일을 막는데 초점이 맞춰져있다.

- ### Context Switching

  - #### Context Switching?

    - 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정을 말한다.

  - #### Context Switching 과정

    - Task의 대부분 정보는 레지스터에 저장되고 PCB로 관리된다.
    - 현재 실행되고 있는 Task의 PCB 정보를 저장하다. (Process Stack, Ready Queue)
    - 다음 실행할 Task의 PCB 정보를 읽어 레지스터에 적재하고, CPU가 이전에 진행했던 과정을 연속적으로 수행할 수 있다.

  - #### Context Switching Cost (Process vs Thread)

    - Process Context Switching 비용 > Thread Context Switching 비용
    - Thread는 Stack 영역을 제외한 모든 메모리를 공유하므로 Context Switching 수행 시 Stack 영역만 변경하면 되기 때문에 비용이 적게 든다.







# 정렬 알고리즘

- 정렬 알고리즘 분류는 다음과 같은 2가지로 구분된다
  - 실행 방법에 따른 분류
  - 정렬 장소에 따른 분류

## 실행 방법에 따른 분류

- 비교식 정렬과 분산식 정렬이 있다.

  #### 비교식 정렬

  - 비교하고자 하는 각 키값들을 한 번에 두 개씩 비교하여 교환하는 방식으로 정렬을 실행하는 방법

  #### 분산식 정렬

  - 키값을 기준으로 하여 자료를 여러 개의 부분 집합으로 분해하고, 각 부분 집합을 정렬함으로써 전체를 정렬하는 방식

## 정렬 장소에 따른 분류

- 내부 정렬과 외부 정렬이 있다.

  #### 내부 정렬

  - 정렬할 자료를 메인 메모리에 올려서 정렬하는 방식이고 정렬 속도가 빠르지만 정렬할 수 있는 자료의 양이 메인 메모리의 용량에 따라서 제한된다.
  - 교환 방식(Selection, Bubble, Quick), 삽입 방식(Insertion, Shell), 병합 방식(2-way 병합, n-way 병합), 분배 방식(Radix), 선택 방식(Heap, Tree) 등이 있다.

  #### 외부 정렬

  - 정렬할 자료를 보조 기억장치에서 정렬하는 방식이고 대용량의 보조 기억 장치를 사용하기 때문에 내부 정렬보다 속도는 떨어지지만 내부 정렬로 처리할 수 없는 대용량의 자료에 대한 정렬이 가능하다.



## 알고리즘 성능

- 일반적으로는 퀵 소트가 제일 빠르다고 알려져 있다. 최악의 경우 n^2이 발생하는데 이는 피봇이 최소값, 최대값으로 잡히게 될 경우이다. 이를 피하기 위해서 피봇을 랜덤으로 잡거나 Media-Of-Three Partitioning이라는 기법을 사용한다. 평균적으로 가장 좋은 성능을 낸다.
- 이미 정렬되어 있는 자료의 경우에는 Insertion Sort가 제일 빠르다. 이미 정렬되어 있는 경우 바로 앞자리 원소와 한 번만 비교하면 되기 때문이다.



### Bubble Sort

- 인접한 두 개의 원소를 비교하여 자리를 교환하는 방식이다.

  1. 첫 번째 원소부터 마지막 원소까지 반복하여 한 단계가 끝나면 가장 큰 원소가 마지막 자리
  2. 맨 오른쪽원소부터 차근차근 내림차순 혹은 오름차순 숫자를 만족함

  ~~~python
  #오름차순
  for i in range(N-1):
    for j in range(N-i-1):
      if num_list[i] > num_list[i+1]:
        num_list[i], num_list[i+1] = num_list[i+1], num_list[i]
  ~~~

  



### Selection Sort

- 전체 원소들 중에서 기준 위치에 맞는 원소를 선택하여 자리를 교환하는 방식이다.

  1. 전체 원소 중에서 가장 작은 원소를 찾아 선택하여 첫 번째 원소와 자리를 교환한다.
  2. 그 다음 두 번째로 작은 원소를 찾아서 선택하여 두 번째 원소와 자리를 교환한다.
  3. 그 다음 세 번쨰로 작은 원소를 찾아서 선택하여 세 번째 원소와 자리를 교환한다.
  4. 이 과정을 반복하면서 정렬이 완성된다.

  ~~~python
  for i in range(N-1):
    min = i
    for j in range(i+1, N):
      if arr[j] < arr[min]:
        min = j
    arr[min], arr[i] = arr[i], arr[min]
  ~~~

  

  

### Insertion Sort

- 정렬되어 있는 부분집합에 정렬할 새로운 원소의 위치를 삽입하는 방법이다.

- 정렬할 자료를 두 개의 부분집합 S와 U로 가정한다.

  1. 부분집합 S : 정렬된 앞 부분의 원소들
  2. 부분집합 U : 아직 정렬되지 않은 나머지 원소들
  3. 정렬되지 않은 부분집합 U의 원소를 하나씩 꺼내서 이미 정렬되어 있는 부분집합 S의 마지막 원소부터 비교하면서 위치를 찾아 삽입한다.
  4. 삽입 정렬을 반복하면서 부분집합 S의 원소는 하나씩 늘리고 부분집합 U의 원소는 하나씩 감소하게 된다.
  5. 부분집합 U가 공집합이 되면 정렬이 완성된다.

  ~~~python
  for i in range(1, N):
    key = num_list[i]
    j = i - 1
    while j >= 0 and num_list[j] > key:
      num_list[j+1] = num_list[j]
      j-=1
    num_list[j+1] = key
  ~~~

  



### Shell Sort

- 일정한 간격으로 떨어져 있는 자료들끼리 부분집합을 구성하고 각 부분집합에 있는 원소들에 대해서 삽입 정렬을 수행하는 작업을 반복하면서 전체 원소들을 정렬하는 방법이다. 전체 원소에 대해서 삽입 정렬을 수행하는 것보다 부분집합으로 나누어 정렬하게 되면 연산이 감소할 수 있는 점에서 착안된 방법
  1. 부분집합의 기준이 되는 간격을 변수에 저장
  2. 한 단계가 수행될 때마다 간격 변수의 값을 감소시키고 쉘 정렬을 순환 호출한다.
  3. 간격 변수가 1이 될 때까지 반복한다.
- 쉘 정렬의 성능은 간격 변수의 값에 따라 달라진다. 정렬할 자료의 특성에 따라 간격 변수 생성 함수를 사용하고 일반적으로 사용하는 간격변수의 값은 원소 개수의 1/2을 사용하고 한 단계 수행될 때마다 또 다시 절반으로 감소시키면서 반복 수행한다.



![sorts](https://evan-moon.github.io/6cfa6f10ba3dfd0a90b03cfb0926f05d/sorts.gif)



- 거꾸로 있는 배열을 정렬하는데에는 ***쉘 정렬*** 이 가장 빠르고, 선택 정렬이 가장 느리다
- 거의 정렬되어 있는 배열을 정렬하는데에는 ***삽입 정렬*** 혹은 ***버블 정렬*** 혹은 ***쉘 정렬***이 빠르다.





![sort-time-complexity](https://gmlwjd9405.github.io/images/algorithm-shell-sort/sort-time-complexity.png)









# Database

## 데이터베이스 풀

- ### Connection Pool

  - 클라이언트의 요청에 따라 각 어플리케이션의 스레드에서 데이터베이스에 접근하기 위해서는 Connection이 필요하다.

  - Connection pool은 이런 Connection을 여러 개 생성해 두어 저장해 놓은 공간(캐시), 또는 이 공간의 Connection을 필요할 때 꺼내 쓰고 반환하는 기법을 말한다.

    ![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/db-img/db-connection-02.png)

- ### DB에 접근하는 단계

  1. 웹 컨테이너가 실행되면서 DB와 연결된 Connection 객체들을 미리 생성하여 pool에 저장한다.

  2. DB에 요청 시, pool에서 Connection 객체를 가져와 DB에 접근한다.

  3. 처리가 끝나면 다시 pool에 반환한다.

     ![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/db-img/db-connection-01.jpeg)

- ### Connection이 부족하면?

  - 모든 요청이 DB에 접근하고 있고 남은 Connection이 없다면, 해당 클라이언트는 대기 상태로 전환시키고 Pool에 Connection이 반환되면 대기 상태에 있는 클라이언트에게 순차적으로 제공된다.

- ### 왜 사용할까?

  - 매 연결마다 Connection 객체를 생성하고 소멸시키는 비용을 줄일 수 있다.
  - 미리 생성된 Connection 객체를 사용하기 때문에, DB 접근 시간이 단축된다.
  - DB에 접근하는 Connection의 수를 제한하여, 메모리와 DB에 걸리는 부하를 조정할 수 있다.

- ### Thread Pool

  - 비슷한 맥락으로 Thread pool이라는 개념도 있다.
  - 이 역시 매 요청마다 요청을 처리할 Thread를 만드는 것이 아닌, 미리 생성한 pool 내의 Thread를 소멸시키지 않고 재사용하여 효율적으로 자원을 활용하는 기법.

- ### Thread Pool과 Connection Pool

  - WAS에서 Thread pool과 Connection pool내의 Thread와 Connection의 수는 직접적으로 메모리와 관련이 있기 때문에, 많이 사용하면 할 수록 메모리를 많이 점유하게 된다. 그렇다고 반대로 메모리를 위해 적게 지정한다면, 서버에서는 많은 요청을 처리하지 못하고 대기 할 수 밖에 없다.
  - 보통 WAS의 Thread의 수가 Connection의 수보다 많은 것이 좋은데, 그 이유는 모든 요청이 DB에 접근하는 작업이 아니기 때문이다.

- ### Web Server와 WAS의 차이

  - Web Server는 jpg, html 등과 같은 정적인 파일만 다룰 수 있다.
  - 그러나 jsp, php, asp 등과 같이 어떠한 프로그래밍 적(동적)인 처리가 필요할 때는 Web Server가 이를 해결해주지 못함. 그래서 Web Server와 Container가 포함된 WAS를 사용함. Web Server가 동적인 처리가 필요할 때 내용들을 컨테이너로 보내서 처리한다.
  - 둘의 가장 큰 차이점은 "상황에 따라 변하는 정보를 제공할 수 있는가"

- ### 트랜잭션

  - #### 트랜잭션이란

    - 데이터베이스 상태를 변환시키는 하나의 논리적인 작업 단위를 구성하는 연산들의 집합이다.

      - 예를 들어, A계좌에서 B계좌로 일정 금액을 이체한다고 가정하자.

        a. A의 계좌의 잔액을 확인한다.

        b. A의 계좌의 금액에서 이체할 금액을 빼고 다시 저장한다.

        c. B의 계좌의 잔액을 확인한다.

        d. B계좌의 금액에서 이체할 금액을 더하고 다시 저장한다.

      - 이러한 과정들이 모두 합져쳐 계좌이체라는 하나의 작업단위를 구성한다.

    - 하나의 트랜잭션은 Commit 되거나 Rollback 된다.

      - Commit 연산
        - 한개의 논리적인 단위에 대한 작업이 성공적으로 끝나 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신이 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산이다.
      - Rollback 연산
        - 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 모든 연산을 취소(Undo)하는 연산이다.
        - Rollback 시에는 해당 트랜잭션을 재시작하거나 없앤다.

  - #### 트랜잭션의 성질(ACID)

    - 원자성(Atomicity), All or nothing
      - 트랜잭션의 모든 연산들은 정상적으로 수행 완료되거나 아니면 전혀 어떠한 연산도 수행되지 않은 상태를 보장해야 한다.
    - 일관성(Consistency)
      - 트랜잭션 완료 후에도 데이터베이스가 일관된 상태로 유지되어야 한다.
    - 독립성(Isolation)
      - 하나의 트랜잭션이 실행하는 도중에 변경한 데이터는 이 트랜잭션이 완료될 때까지 다른 트랜잭션이 참조하지 못한다.
    - 지속성(Durability)
      - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다.

  - #### 트랜잭션의 필요성

    - 현금 인출기를 작동하는 도중에 기계오류나 정전 등과 같은 예기치 않은 상황이 발생하여 카드가 나오지 않거나 기계가 멈추는 경우
    - 각각 다른 지점의 은행에서 동시에 인출할 때, 하나의 지점이 다른 지점에서 저장한 잔액을 덮어 쓰는 경우
    - 위와 같은 상황이 발생되지 않도록 방지에 필요한 트랜잭션의 성질인 ACID를 제공받기 위해 트랜잭션을 사용한다.

  - #### 트랜잭션의 상태

    ![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/transaction-status.png)

    - 활동(Active)
      - 트랜잭션이 실행 중에 있는 상태, 연산들이 정상적으로 실행 중인 상태
    - 장애(Failed)
      - 트랜잭션이 실행에 오류가 발생하여 중단된 상태
    - 철회(Aborted)
      - 트랜잭션이 비정상적으로 종료되어 Rollback을 수행한 상태
    - 부분 완료(Partially Committed)
      - 트랜잭션이 마지막 연산까지 실행됐지만, Commit 연산이 실행되기 직전의 상태
    - 완료
      - 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

  ### 트랜잭션 격리 수준

  - #### Isolation Level?

    - 트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준

  - #### Isolation Level의 필요성

    - DB는 ACID 같이 트랜잭션이 원자적이면서 독립적인 수행을 하도록 한다.
    - 그래서 Locking 이라는 개념이 등장한다.
      - 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하게 막는 것
    - 하지만, 무조건적인 Locking으로 동시에 수행되는 많은 트랜잭션들을 순서대로 처리하는 방식으로 DB를 구현하면 성능이 떨어지게 된다.
    - 반대로 응답성을 높이기 위해 Locking 범위를 줄인다면 잘못된 값이 처리 될 여지가 있다.
    - 그래서 효율적인 Locking 방법이 필요하다.

  - #### Isolation Level의 종류

    - Read Uncommitted (레벨 0)
      - SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 Level
      - 트랜잭션에 처리중인 혹은 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.
      - 따라서, 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 아직 완료되지 않은 트랜잭션이지만 변경된 데이터 B를 읽을 수 있다.
      - 데이터베이스의 일관성을 유지할 수 없다.
    - Read Committed (레벨 1)
      - SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 Level
      - 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 된다.
      - Commit이 이루어진 트랜잭션만 조회할 수 있다.
      - 따라서, 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 해당 데이터에 접근할 수 없다.
      - SQL Server가 Default로 사용하는 Isolation Level
    - Repeatable Read (레벨 2)
      - 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 Level
      - 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장한다.
      - 따라서, 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정이 불가능하다.
    - Serializable (레벨 3)
      - 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 Level
      - 완벽한 읽기 일관성 모드를 제공한다.
      - 따라서, 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능하다.
    - Isolation Level 조정은 동시성이 증가되는데 반해 데이터 무결성 문제가 발생할 수 있고, 데이터의 무결성을 유지하는 데 반해 동시성이 떨어질 수 있다.

  - #### 낮은 단계의 Isolation Level 이용시 발생하는 현상

    - Dirty Read
      - 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상
      - 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경 사항을 보게 되는 경우
    - Non-Repeatable Read
      - 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리의 결과가 상이하게 나타나는 비 일관성
    - Phantom Read
      - 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽을 떄, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상
      - 이는 트랜잭션 도중 새로운 레코드가 삽입되는 것을 허용하기 때문

  

  ## SQL Injection

  - ### Index 란?

    - 데이터베이스에서 조회 및 검색을 더 빠르게 할 수 있는 방법/기술, 혹은 이에 쓰이는 자료구조 자체를 의미하기도 한다.

  - ### 사용이유

    - Select 문을 사용하여 원하는 조건의 데이터를 검색할 때, 저장된 데이터의 양이 엄청나게 많다면 검색을 위한 순회에 많은 자원과 시간이 소모될 것이다. 이때 도움이 되는게 인덱스이다.
    - 자주 조회되는 Column에 대한 Index Table을 따로 만들어 SELECT 문이 들어왔을 때, Index 테이블에 있는 값들로 결과를 조회해 온다. 그래서 Index를 잘 사용한다면 "검색" 연산을 실행했을 때 성능을 올릴 수 있게 된다.

  - ### 동작

    - Index Table에서 where에 포함된 값을 검색
    - 해당 값의 table_id PK를 획득
    - 가져온 table_id PK값으로 원본 테이블에서 값을 조회

    DBMS는 인덱스를 다양한 알고리즘으로 관리를 하고 있는데 일반적으로 사용되는 알고리즘은 B+ Tree 알고리즘이다.

  - ### B+tree 알고리즘

    ![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/db-btree.png)

    - 실제 데이터가 저장된 리프노드
    - 리프노드까지 경로 역할을 하는 논리프노드
    - 경로의 출발점이 되는 루트노드

    B+tree는 리프노드에 이르기까지에 대한 자식 노드에 포인터가 저장되어 있다. 즉, B+tree의 검색은 루트노드에서 어떤 리프노드에 이르는 한 개의 경로만 검색하면 되므로 매우 효율적이다.

    #### B+tree 사용 이유

    - 왜 index 생성시 B+tree를 사용하는지? Hash table이 더 효율적이지 않은지?
      - SELECT 질의 조건에는 부등호 연산(<>)도 포함
      - Hash table은 동등 연산에 특화된 자료구조이기 때문에 부등호 연산 사용시 문제 발생

  - ### 주의할 점

    - 인덱스는 따로 테이블의 형태로 관리가 된다. 자원을 소모한다는 의미. 때문에 무분별한 인덱스의 사용은 성능에 부정적인 영향을 미칠 수 있다.
    - 또한 인덱스는 이진트리를 사용하기 때문에 기본적으로 정렬되어 있다. 이로인해 검색과 조회의 속도를 향상시킬 수 있지만 잦은 데이터의 변경(삽입, 삭제, 수정)이 된다면 인덱스 테이블을 변경과 정렬에 드는 오버헤드 때문에 오히려 성능 저하가 일어날 수 있다.
      - INSERT : 테이블에는 입력 순서대로 저장되지만, 인덱스 테이블에는 정렬하여 저장하기 때문에 성능 저하 발생
      - DELETE : 테이블에서만 삭제되고 인덱스 테이블에는 남아있는 쿼리 수행 속도 저하
      - UPDATE : 인덱스에는 UPDATE가 없기 때문에 DELETE, INSERT 두 작업 수행하여 부하 발생
    - 데이터의 중복이 높은 컬럼은 인덱스로 만들어도 무용지물(예시 : 성별)
    - 다중 컬럼 인덱싱할 때 카디널리티가 높은 컬럼 -> 낮은 컬럼 순으로 인덱싱해야 효율적

  

  ## 파티셔닝

  - ### 배경

    - 서비스의 크기가 점점 커지고 DB에 저장하는 데이터의 규모 또한 대용량화 되면서, 기존에 사용하는 DB 시스템의 용량의 한계와  성능의 저하를 일으켰다.
    - 즉, VLDB(Very Large DB)와 같이 하나의 DBMS에 너무 큰 table이 들어가면서 용량과 성능 측면에서 많은 이슈가 발생하게 되었고, 이런 이슈를 해결하기 위한 방법으로 table을 '파티션'이라는 작은 단위로 나누어 관리하는 '파티셔닝' 기법이 나타나게 되었다.

  - ### 파티셔닝의 개념

    - 큰 table이나 index를 관리하기 쉬운 partition이라는 작은 단위로 물리적으로 분할하는 것을 의미한다.
      - 물리적인 데이터 분할이 있더라도, DB에 접근하는 application의 입장에서는 이를 인식하지 못한다.
    - '파티셔닝' 기법을 통해 소프트웨어적으로 데이터베이스를 분산 처리하여 성능이 저하되는 것을 방지하고 관리를 보다 수월하게 할 수 있게 된다.

  - ### 파티셔닝의 목적

    - 성능
      - 특정 DML과 Query의 성능을 향상 시킨다.
        - DML : SELECT, INSERT, DELETE, UPDATE
        - DDL : CREATE, ALTER, DROP, RENAME, TRUNCATE
        - DCL : GRANT, REVOKE
        - TCL : COMMIT, ROLLBACK, SAVEPOINT
    - 가용성
      - 물리적인 파티셔닝으로 인해 전체 데이터의 훼손 가능성이 줄어들고 데이터 가용성이 향상된다.
      - 각 분할 영역을 독립적으로 백업하고 복구할 수 있다.
      - table의 partition 단위로 Disk I/O를 분산하여 경합을 줄이기 때문에 UPDATE 성능을 향상 시킨다.
    - 관리용이성
      - 큰 table들을 제거하여 관리를 쉽게 해준다. 

  - ### 파티션의 장/단점

    - #### 장점

      - 괸리적인 측면 : partition 단위 백업, 추가, 삭제, 변경
        - 전체 데이터를 손실할 가능성이 줄어들어 데이터 가용성이 향상된다.
        - partition별로 백업 및 복구가 가능하다.
        - partition 단위로 I/O 분산이 가능하여 UPDATE 성능을 향상
      - 성능적 측면 : partition 단위 조회 및 DML 수행
        - 데이터 전체 검색 시 필요한 부분만 탐색해 성능이 증가한다.
        - 즉, Full Scan에서 데이터 Access의 범위를 줄여 성능 향상
        - 필요한 데이터만 빠르게 조회할 수 있기 때문에 쿼리 자체가 가볍다.

    - #### 단점

      - table간 조인 비용이 증가한다.
      - table과 index를 별도로 파티셔닝할 수 없다.
        - tabler과 index를 같이 파니셔닝 해야 한다.

  - ### 파티셔닝의 종류

    - #### 수평 파티셔닝

    - #### 수직 파티셔닝

  - ### 파니셔닝의 분할 기준

    1. 범위 분할
    2. 목록 분할
    3. 해시 분할
    4. 합성 분할

    ![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/partitioning.png)

  

  ## ORM 이란?

  > Object-Relational-Mapping

  - 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해주는 것을 말한다.

  

  ### 영속성

  - 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않은 데이터의 특성
  - 영속성을 갖지 않는 데이터는 단지 메모리에서만 존재하기 때문에 프로그램을 종료하면 모두 잃어버리게 된다. 때문에 파일 시스템, 관계형 데이터베이스 혹은 객체 데이터베이스 등을 활용하여 데이터를 영구 저장하여 영속성을 얻는다.

  

  ### Persistence layer

  - 프로그램의 아키텍처에서 데이터에 영속성을 부여해주는 계층. JDBC를 이용하여 직접 구현할 수 있지만 Persistence framework를 이용한 개발이 많이 이루어진다.

    ![1](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/persistence-layer.png)

  ### Persistence framework

  > JDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업만으로 데이터베이스와 연동되는 시스템을 빠르게 개발할 수 있으며 안정적인 구동을 보장한다.

  - #### 종류

    - SQL 문장으로 직접 데이터베이스 데이터를 다루는 SQL 맵퍼
      - Mybatis
    - 객체를 통해 간접적으로 데이터베이스 데이터를 다루는 객체 관계 맵퍼(ORM)
      - Hibernates

  - #### 장점 - 왜 사용하는가?

    > 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와준다.

    - 선언문, 할당, 종료 같은 부수적인 코드가 없거나 급격히 줄어든다.
    - 각종 객체에 대한 코드를 별도로 작성하기 때문에 코드의 가독성을 올려준다.
    - SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증ㅁ가한다.

    > 재사용 및 유지보수의 편리성이 증가한다.

    - ORM은 독립적으로 작성되어있고, 해당 객체들은 재활용 할 수 있다.
    - 때문에 모델에서 가공된 데이터를 컨트롤러에 의해 뷰와 합쳐지는 형태로 디자인 패턴을 견고하게 다지는데 유리하다.
    - 매핑정보가 명확하여 ERD를 보는 것에 대한 의존도를 낮출 수 있다.

    > DBMS에 대한 종속성이 줄어든다.

    - 대부분 ORM 솔루션은 DB에 종속적이지 않다.
    - 종속적이지 않다는것은 구현 방법뿐만 아니라 많은 솔루션에서 자료형 타입까지 유효하다.
    - 프로그래머는 객체에 집중함으로 극단적으로 DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간이 소요된다.

  - #### 단점

    > 완벽한 ORM으로만 서비스를 구현하기 어렵다.

    - 사용하기 편하지만 설계는 매우 신중하게 해야한다.
    - 프로젝트의 복잡성이 커질 경우 난이도 또한 올라감
    - 잘못 구현된 경우에 안 한것보다 못함
    - 일부 자주 사용되는 대형 쿼리는 속도를 위해 SP를 쓰는등 별도의 튜닝이 필요한 경우가 있다.
    - DMBS의 고유 기능을 이용하기 어렵다. (하지만 이건 단점으로만 볼 수 없다 : 특정 DBMS의 고유 기능을 이용하면 이식성이 저하된다.)

    > 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.

    - 이미 프로시저가 많은 시스템에선 다시 객체로 바꿔야하며, 그 과정에서 생산성 저하, 리스크가 발생

  

  ## JDBC를 이용한 DB접근

  - 순서
    1. JDBC driver 로딩
    2. Connection 맺기
    3. SQL 실행
    4. 자원 반환

  

  

















































































