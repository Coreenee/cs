# Brand Experience

- 브랜드가 고객을 만나는 모든 활동, 경험
- Brand, Experience, Design을 하나라 통합한 의미
- 기업의 브랜드를 소비자들이 경험할 수 있도록 디자인하고 기획하는 것을 의미
- 조금 더 쉽게 설명하자면, 기업들은 고유의 브랜드를 가지고 있다. 소비자는 기업의 브랜드를 다양한 채널, 접점을 통하여 경험을 한다. 예를들어, 회사의 로고를 반복적으로 접하거나, 기업의 제품을 구매하기 위해 홈페이지에 들어가거나, 광고를 통해서 접할 수도 있다. -> 소비자는 기업을 경험할 수 있는 다양한 접점과 지속적으로 마주하게 됩니다.
- 기업에서 추구하는 브랜드의 목표와 가치를 다양한 미디어의 마케팅접점에서 사용자들에게 정확히 전달 할 수 있는 경험을 기획하고 이를 위한 최적을 디자인을 하는 것
- 브랜드 경험이 중요한 이유는 소비자들에게 호감과 애착을 형성하고, 그들이 기업이 바라는 대로 이끌 수 있다는 점
  - 소비자들은 기업이 표방하는 가치를 원하여 브랜드를 구매하게 된다.
- 최근의 추세는 브랜드 경험이라는 분야를 선호하는 상황. 기업의 고유한 가치를 소비자들도 인식하게 됌. 또한, 단지 '제품을 구매한다'는 측면에서 벗어나 소비자들이 기업이 추구하는 '가치를 구매한다'는 성향을 갖게 된 것. 가치를 구매하기 때문에 자신이 추구하는 가치와 부합되는 브랜드를 구매하고 선호하는 현상이 확산됨
- 브랜드 경험이 다양한 매체를 통해 이루어지기 때문에, 모든 매체에서 일관된 모습을 드러나야 한다. 하나의 방향성과 일관된 형태를 통해 소비자에게 혼란의 여지 없는 정확한 브랜드 경험을 심어줄 수 있다. 또한, 소비자 뿐만 아니라 기업 내부 직원들에게까지 일관된 브랜드 경험을 제공해주어, '하나의 브랜드 경험, 브랜드 가치'를 전달하는 것.





# Hash Table

## Hash Table 동작 과정

1. Key -> Hash Function -> 결과 = Hash
2. Hash를 배열의 Index로 사용
3. 해당 Index에 Value 저장



## Hash 충돌

1. 서로 다른 key가 Hash Function에서 중복 Hash로 나오는 경우
2. 충돌이 많아질수록 탐색의 시간 복잡도가 O(1)에서 O(n)으로 증가

### Hash 충돌 해결 방법

1. Seperating Chaining
   - JDK 내부에서 사용하는 충돌 처리 방식
   - Linked List로 Hash값이 같은 Value 값 연결
2. Open addressing
   - 추가 메모리 공간을 사용하지 않고, Hash Table 배열의 빈 공간을 사용하는 방법
3. Resizing
   - 저장 공간이 일정 수3준 채워지면 Seperating Chaining의 경우 성능 향상을 위해 Open addressing의 경우 배열 크기 확장을 위해 Resizing
   - 보토 2배로 확장



## Hash Table의 장점

1. 작은 리소스로 많은 데이터를 효율적으로 관리 가능
2. 배열의 인덱스를 사용하기 때문에 빠른 검색, 삽입, 삭제 O(1)
3. Key와 Hash에 연관성이 없어 보안에 유리
4. 중복 제거 유용

## Hash Table의 단점

1. 충돌 발생 가능성
2. 공간 복잡도 무시
3. 순서 무시
4. 해시 함수에 의존



## Hash Table vs Hash Map

- Hash Table
  - 비동기 (단일 스레드)에서 사용
  - null 값 허용
- Hash Map
  - 동기 (멀티 스레드)에서 사용
  - null 값 미허용





# Stack

- LIFO
- 재귀 알고리즘
- 웹 브라우저 방문기록
- 실행 취소
- 역순 문자열 만들기
- 수식의 괄호 검사 (VPS, Valid Parenthesis String)
- 후휘 표기법 검사

# Queue

- FIFO
- BFS 구현
- 캐시 구현
- 우선순위가 같은 작업 예약 (인쇄 대기열)
- 선입선출이 필요한 대기역 (티켓 카운터)
- 콜센터 고객 대기시간
- 프린터의 출력 처리
- 프로세스 관리



---



# Network

## OSI 7계층

- ISO에서 개발한 모델로, 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명
- 프로토콜을 기능별로 나눈 것

1. 물리 계층
   - 네트워크의 기본 네트워크 하드웨어 전송 기술을 이룬다.
   - 네크워크의 높은 수준의 기능의 논리 데이터 구조를 기초로 하는 필수 계층이다.
   - 전송 단위는 Bit이다.
2. 데이터 링크 계층
   - P2P 간 신뢰성 있는 전송을 보장하기 위한 계층으로 CRC 기반의 오류 제어와 흐름 제어가 필요하다.
   - 주소 값은 물리적으로 할당 받는데, 이는 네트워크 카드가 만들어질 때부터 맥 주소가 정해져 있다는 뜻이다.
   - 데이터 링크 계층의 대표적 예는 이더넷이다.
   - 전송 단위는 Frame이다.
3. 네트워크 계층
   - 여러개의 노드를 거칠때마다 경로를 찾아주는 역할 하는 계층으로 다양한 길이의 데이터를 네트워크들을 통해 전달하고, 그 과정에서 전송 계층이 요구하는 서비스 품질(QoS)를 제공하기 위한 기능적, 절차적 수단을 제공한다.
   - 네트워크 계층은 라우팅, 흐름 제어, 세그멘테이션, 오류 제어 등을 수행한다.
   - 논리적인 주소 구조(IP), 곧 네트워크 관리자가 직접 주소를 할당하는 구조를 가지며, 계층적이다.
   - 데이터 전송 단위는 Datagram(Packet)이다.
4. 전송 계층
   - E2E의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해 주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다.
   - 시퀀스 넘버 기반의 오류 제어 방식을 사용한다.
   - 전송 계층이 패킷들의 전송이 유효한지 확인하고 전송 실패한 패킷들을 다시 전송한다.
   - 가장 잘 알려진 전송 계층의 예는 TCP이다.
   - 전송 단위는 Segment이다.
5. 세션 계층
   - 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.
   - Duplex, half-duplex, full-duplex의 통신과 함께, 체크 포인팅과 유휴, 종료, 다시 시작 과정 등을 수행한다.
   - 이 계층은 TCP/IP 세션을 만들고 없애는 역할을 한다.
6. 표현 계층
   - 코드 간의 번역을 담당, 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어 준다.
   - 인코딩이나 암호화 등의 동작이 이 계층에서 이루어진다.
7. 응용 계층
   - 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.



## TCP와 UDP

- 네트워크 계층 중 전송 계층에서 사용하는 프로토콜

### TCP

- 인터넷 상에서 데이터를 메세지의 형태(세그먼트 라는 블록 단위)로 보내기 위해 IP와 함께 사용하는 프로토콜이다.
- TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리한다.
- 연결형 서비스로 가상 회선 방식을 제공한다.
  - 3-way handshaking 과정을 통해 연결을 설정하고, 4-way handshaking을 통해 연결을 해제한다.
- 흐름 제어 및 혼잡제어를 제공한다.
  - 흐름제어
    - 데이터를 보내는 곳과 받는 곳의 데이터 처리 속도를 조절하여 받는 곳의 버퍼 오버플로우를 방지하는 것
  - 혼잡제어
    - 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것
    - 정보의 소통량이 과다하면 패킷을 조금만 전송하여 혼잡 붕괴 현상이 일어나는 것을 막는다.
  - 높은 신뢰성을 보장한다.
  - UDP보다 속도가 느리다.
  - Full-Duplex, Point-to-Point 방식이다.
    - Full-Duplex
      - 전송이 양방향으로 동시에 일어날 수 있다.
    - Point-to-Point
      - 각 연결이 정확히 2개의 종단점을 가지고 있다.
    - 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.
  - 연속성보다 신뢰성 있는 전송이 중요할 때 사용

### UDP

- 데이터를 데이터 그램 단위로 처리하는 프로토콜이다.
- 비연결형 서비스로 데이터그램 방식을 제공한다.
  - 연결을 위해 할당되는 논리적인 경로가 없다.
  - 따라서, 각각의 패킷은 다른 경로로 전송되고, 각각의 패킷은 독릭접인 관계를 갖게 된다.
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
- UDP헤더에서 checksum 필드를 통해 최소한의 오류만 검출한다.
- 신뢰성이 낮다.
- TCP보다 속도가 빠르다.
- 신뢰성보다는 연속성이 중요한 서비스, 스트리밍에 사용된다.

### 참고

- UDP와 TCP는 각각 별도의 포트 주소 공간을 관리하므로 같은 포트 번호를 사용해도 무방하다. 즉, 두 프로토콜에서 동일한 포트 번호를 할당해도 서로 다른 포트로 간주한다.



### TCP의 3 way handshake 와 4 way handshake

- TCP는 장치들 사이에 논리적인 접ㅂ속을 성립하기 위하여 연결을 설정하여 신뢰성을 보장하는 연결형 서비스이다.

#### 3 way handshake

- TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정
- 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장, 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었다는 것을 알 수 있게 해준다.
- 즉, TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.
  - A 프로세스(Client)가 B 프로세스(Server)에 연결을 요청![3-way-handshaking](/Users/ryuseungmin/Desktop/dev사진/3-way-handshaking.png)
    - A -> B : SYN
      - 접속 요청 프로세스 A가 연결 요청 메시지 전송 (SYN)
      - 송신자가 최초로 데이터를 전송할 때 Sequence Number를 임의 랜덤 숫자로 지정하고, SYN 플래그 비트를 1로 설정한 세그먼트를 전송한다.
    - B -> A : SYN + ACK
      - 접속 요청을 받은 프로세스 B가 요청을 수락했으며, 접속 요청 프로세스인 A도 포트를 열어 달라는 메시지 전송 (SYN + ACK)
      - 수신자는 ACK# 필드를 Sequence# + 1로 지정하고, SYN과 ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
    - A -> B : ACK
      - 마지막으로 접속 요청 프로세스 A가 수량 확인을 보낸 연결을 맺음 (ACK)
      - 이때, 전송할 데이터가 있으면 이 단계에서 데이터를 전송할 수 있다.

#### 4 way handshake

- TCP의 연결을 해체하는 과정

  - A 프로세스(Client)가 B 프로세스(Server)에 연결 해제를 요청

    ![4-way-handshaking](/Users/ryuseungmin/Desktop/dev사진/4-way-handshaking.png)

  - A -> B: FIN

    - 프로세스 A가 연결을 종료하겠다는 FIN 플래그를 전송
    - 프로세스 B가 FIN 플래그로 응답하기 전까지 연결을 계속 유지

  - B -> A : ACK

    - 프로세스 B는 일단 확인 메시지를 보내고 자신의 통신이 끝날 때까지 기다린다.
    - 수신자는 ACK$ 필드를 Seq# + 1로 지정하고, ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
    - 그리고 자신이 전송할 데이터가 남아있다면 이어서 계속 전송한다.

  - B -> A : FIN

    - 프로세스 B가 통신이 끝났으면 연결 종료 요청에 합의한다는 의미로 프로세스 A에게 FIN 플래그를 전송

  - A -> B : ACK

    - 프로세스 A는 확인했다는 메시지를 전송

  #### TCP 관련 질문

  - TCP의 연결 설정 과정과 연결 종료 과정이 단계가 차이나는 이유?
    - 클라이언트가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 떄문이다.
  - 만약 서버에서 FIN 플래그를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?
    - 이러한 현상에 대비하여 클라이언트는 서버로부터 FIN 플래그를 수신하더라도 일정 시간동안 세션을 남겨 놓고 잉여 패킷을 기다리는 과정을 거친다.
  - 초기 Seq# 인 ISN을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유는?
    - 연결을 맺을 때 사용하는 포트는 유한 범위 내에서 사용하고, 시간이 지남에 따라 재사용 된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다. 서버 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 #가 전송된다면 이전의 연결로부터 오는 패킷으로 인식할 수 이있다. 이런 문제가 발생할 가능성을 줄이기 위해 난수를 설정한다.



### HTTP와 HTTPS

- HTTP 프로토콜
  - 개념
    - HyperText Transfer Protocol
    - 웹 상에서 클라이언트와 서버 간에 요청/응답으로 정보를 주고 받을 수 있는 프로토콜
  - 특징
    - 주로 HTML 문서를 주고 받는 데에 쓰인다.
    - TCP와 UDP를 사용하며, 80번 포트를 사용.
    - 비연결
      - 클라이언트가 요청을 서버에 보내고 서버가 적절한 응답을 클라이언트에 보내면 바로 연결이 끊긴다.
    - 무상태
      - 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다.
- HTTPS 프로토콜
  - 개념
    - HTTP over TLS, HTTP over SSL, HTTP Secure
    - 웹 통신 프로토콜인 HTTP의 보안이 강화된 버전의 프로토콜
  - 특징
    - HTTPS의 기본 TCP/IP 포트로 443번 포트를 사용한다.
    - HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에, 웹 상에서 정보를 암호화하는 SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화한다.
      - TLS(Transport Layer security) 프로토콜은 SSL(Secure Socket Layer) 프로토콜에서 발전한 것이다.
      - 두 프로토콜의 주요 목표는 기밀성, 데이터 무결성, ID 및 디지털 인증서를 사용한 인증을 제공하는 것이다.
    - 따라서 데이터의 적절한 보호를 보장한다.
      - 보호의 수준은 웹 브라우저에서의 구현 정확도와 서버 소프트웨어, 지원하는 암호화 알고리즘에 달려있다.
    - 금융 정보나 메일 등 중요한 정보를 주고받는 것은 HTTPS를, 아무나 봐도 상관없는 페이지는 HTTP를 사용한다.
- HTTPS가 필요한 이유
  - 클라이언트인 웹브라우저가 서버에 HTTP를 통해 웹 페이지나 이미 정보를 요청하면 서버는 이 요청에 응답하여 요구하는 정보를 제공하게 된다.
  - 웹 페이지(HTML)는 텍스트이고, HTTP를 통해 이런 텍스트 정보를 교환하는 것이다.
  - 이때 주고받는 텍스트 정보에 주번이나 비번과 같이 민감한 정보가 포함된 상태에서 네트워크 상에서 중간에 제 3자가 정보를 가로챈다면 보안상 큰 문제가 발생한다.
  - 즉, 중간에서 정보를 볼 수 없도록 주고받는 정보를 암호화하는 방법인 HTTPS를 사용하는 것이다.
- HTTPS의 원리
  - 공개키 알고리즘 방 (비대칭키 암호화 방식)
    - 공개키와 개인키를 이용한 암호화 방식
  - 암호화, 복호화시킬 수 있는 서로 다른 키를 이용한 방법
    - 공개키 : 모두에게 공개, 공개키 저장소에 등록
    - 개인키 : 개인에게만 공개, 클라이언트-서버 구조에서는 서버가 가지고 있는 비공개키
  - 클라이언트 -> 서버
    - 사용자의 데이터를 공개키로 암호화 (공개키를 얻은 인증된 사용자)
    - 서버로 전송 (데이터를 가로채도 개인키가 없으므로 복호화할 수 없음)
    - 서버의 개인키를 통해 복호화하여 요청 처리
- HTTPS의 장단점
  - 장점
    - 네트워크 상에서 열람, 수정이 불가능하므로 안전하다.
  - 단점
    - 암호화를 하는 과정이 웹 서버에 부하를 준다.
    - HTTPS는 설치 및 인증서를 유지하는데 추가 비용이 발생한다.
    - HTTP에 비해 느리다.
    - 인터넷 연결이 끊긴 경우 재인증 시간이 소요된다.
      - HTTP는 비연결형으로 웹 페이지를 보는 중 인터넷 연결이 끊겼다가 다시 연결되어도 페이지를 계속 볼 수 있다.
      - 그러나 HTTPS의 경우에는 소켓(데이터를 주고 받는 경로) 자체에서 인증을 하기 때문에 인터넷 연결이 끊기면 소켓도 끊어져서 다시 HTTPS 인증이 필요하다.



### GET & POST

- HTTP 프로토콜을 이용해서 서버에 데이터를 전달할 때 사용하는 방식
- GET 방식
  - 개념
    - 정보를 조회하기 위한 메소드
    - 서버에서 어떤 데이터를 가져와서 보여주기 위한 용도의 메소드
    - 가져오는 것(Select)
  - 사용 방법
    - URL의 끝에 '?' 가 붙고, 요청 정보가 (key=value) 형태의 쌍을 이루어 ?뒤에 이어서 붙어 서버로 전송한다.
    - 전송하는 정보가 여러개일 경우에는 &로 구분한다.
    - e.g.) www.server.com?name1=value1&name2=value2
  - 특징
    - URL에 요청 정보를 붙여서 전송한다.
    - URL에 요청 정보가 이어붙기 때문에 길이 제한이 있어서 대용량의 데이터를 전송하기 어렵다.
    - 요청 정보를 사용자가 쉽게 눈으로 확인 가능하다.
    - HTTP 패킷의 Body는 비어 있는 상태로 전송한다.
    - POST 방식보다 빠르다.
      - GET 방식은 캐싱을 사용할 수 있어, GET 요청과 그에 대한 응답이 브라우저에 의해 캐쉬된다.
- POST 방식
  - 개념
    - 서버의 값이나 상태를 바꾸기 위한 용도의 메소드
    - 수행하는 것(Insert, Update, Delete)
  - 사용 방법
    - 요청 정보를 HTTP 패킷의 Body 안에 숨겨서 서버로 전송한다.
  - 특징
    - Body 안에 숨겨서 요청 정보를 전송하기 때문에 대용량의 데이터를 전송하기에 적합하다.
    - 클라이언트 쪽에서 데이터를 인코딩하여 서버로 전송하고, 이를 받은 서버 쪽이 해당 데이터를 디코딩한다.
    - GET 방식보다 보안상 안전하다.
- POST/GET 질문
  - 조회하기 위한 용도 POST가 아닌 GET 방식을 사용하는 이유?
    - 설계 원칙에 따라 GET 방식은 서버에게 여러 번 요청을 하더라도 동일한 응답이 돌아와야 한다.
      - GET 방식은 가져오는 것(Select)으로 서버의 데이터나 상태를 변경시키지 않아야 한다.
        - e.g.) 게시판 리스트, 글 보기
      - POST 방식은 수행하는 것으로, 서버의 값이나 상태를 바꾸기 위한 용도이다.
        - e.g.) 게시판에 글쓰기 기능
    - 웹에서 모든 리소스는 Link 할 수 있는 URL을 가지고 있어야한다.
      - 어떤 웹페이지를 보고 있을 때 다른 사람한테 그 주소를 주기 위해서 주소창의 URL을 복사해서 줄 수 있어야 한다.
      - 즉, 어떤 웹페이지를 조회할 때 원하는 페이지로 바로 이동하거나 이동시키기 위해서는 해당 링크의 정보가 필요하다.
      - 이때 POST 방식을 사용할 경우에 값(링크의 정보)이 Body에 있기 때문에 URL만 전달할 수 없으므로 GET 방식을 사용해야 한다. 그러나 글을 저장하는 경우에는 URL을 제공할 필요가 없기 때문에 POST 방식을 사용한다.



### 쿠키와 세션

- HTTP 프로토콜의 특징

  - 비연결 지향 
    - 클라이언트가 request를 서버에 보내고, 서버가 클라이언트에 요청에 맞는 response르 보내면 바로 연결을 끊는다.
  - 상태정보를 유지 안함
    - 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다.

- 쿠키와 세션의 필요성

  - HTTP 프로토콜은 위와 같은 특징으로 모든 요청 간 의존관계가 없다.
  - 즉, 현재 접속한 사용자가 이전에 접속했던 사용자와 같은 사용자인지 아닌지 알 수 있는 방법이 없다.
  - 계속해서 연결을 유지하지 않기 때문에 리소스 낭비가 줄어드는 것이 큰 장점이지만, 통신할 때마다 새로 연결하기 때문에 클라이언트는 매 요청마다 인증을 해야 한다는 단점이 있다.
  - 이전 요청과 현재 요청이 같은 사용자의 요청인지 알기 위해서는 상태를 유지해야 한다.
  - HTTP 프로토콜에서 상태를 유지하기 위한 기술로 쿠키와 세션이 있다.

- 쿠키(Cookie)란?

  - 개념

    - 클라이언트 로컬에 저장되는 키와 값이 들어있는 파일이다.
    - 이름, 값, 유효 시간, 경로 등을 포함하고 있다.
    - 클라리언트의 상태 정보를 브라우저에 저장하여 참조한다.

  - 동작 방식

    ![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/cookie-process.png)

    

    - 웹 브라우저가 서버에 요청
    - 상태를 유지하고 싶은 값을 쿠키로 생성
    - 서버가 응답할 때 HTTP 헤더에 쿠키를 포함해서 전송
    - 전달받은 쿠키는 웹브라우저에서 관리하고 있다가, 다음 요청 떄 쿠키를 HTTP 헤더에 넣어서 전송
    - 서버에서는 쿠키 정보를 읽어 이전 상태 정보를 확인하 후 응답

- 세션이란?

  - 개념

    - 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술이다.
    - 즉, 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태이다.

  - 동작 방식

    ![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/session-process.png)

    - 웹 브라우저가 서버에 요청
    - 서버가 해당 웹브라우저에 유일한 ID를 부여함
    - 서버가 응답할 때 HTTP 헤더에 세션 ID를 포함해서 전송, 쿠키에 세션 ID를 저장
    - 웹브라우저는 이후 웹브라우저를 닫기까지 다음 요청 때 부여된 세션 ID가 담겨있는 쿠키를 HTTP 헤더에 넣어서 전송
    - 서버는 세션 ID를 확인하고, 해당 세션에 관련된 정보를 확인한 후 응답

  - 세션 사용 예

    - 로그인

  - 세션도 쿠키를 사용하여 값을 주고받으며 클라이언트의 상태 정보를 유지한다. 즉, 상태 정보를 유지하는 수단은 쿠키 이다.

- 쿠키와 세션의 차이점

  - 저장 위치
    - 쿠키 : 클라이언트
    - 세션 : 서버
  - 보안
    - 쿠키 : 클라이언트에 저장되므로 보안에 취약하다.
    - 세션 : 쿠키를 이용해 세션 ID 만 저장하고 이 값으로 구분해서 서버에서 처리하므로 비교적 보안성이 좋다.
  - 라이프사이클
    - 쿠키 : 만료시간에 따라 브라우저를 종료해도 계속해서 남아 있을 수 있다.
    - 세션 : 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.
  - 속도
    - 쿠키 : 클라이언트에 저장되어서 서버에 요청 시 빠르다.
    - 세션 : 실제 저장된 정보가 서버에 있으므로 서버의 처리가 필요해 쿠키보다 느리다.







### REST와 RESTful의 개념

- REST란
  - REST의 정의
    - Representational State Transfer
    - www과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 개발 아키텍처의 한 형식
      - REST는 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일이다.
      - REST는 네트워크 상에서 클라이언트와 서버 사이의 통신 방식 중 하나이다.
  - REST의 구체적인 개념
    - HTTP URI(Uniform Resource Identifier)를 통해 자원을 명시하고, HTTP Method(Post, Get, Put, Delete)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.
      - 즉, REST는 자원 기반의 구조(ROA, Resource Oriented Architecture) 설계 중심에 Resource가 있고, HTTP 메소드를 통해 Resource를 처리하도록 설계된 아키텍처를 의미한다.
      - 웹 사이트의 이미지, 텍스트, DB 내용 등의 모든 자원에 고유한 ID인 HTTP URI를 부여한다.
  - REST 장단점
    - 장점
      - 여러 가지 서비스 디자인에서 생길 수 있는 문제를 최소화해준다.
      - Hypermedia API의 기본을 충실히 지키면서 범용성을 보장한다.
      - HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 해준다.
    - 단점
      - 브라우저를 통해 테스트할 일이 많은 서비스라면 쉽게 고칠 수 있는 URL보다 Header 값이 왠지 더 어렵게 느껴진다.
      - 구형 브라우저가 아직 제대로 지원해주지 못하는 부분이 존재한다.
        - PUT, DELETE를 사용하지 못하는 점
        - pushState를 지원하지 않는 점
  - REST가 필요한 이유
    - '애플리케이션 분리 및 통합'
    - '다양한 클라이언트의 등장'
    - 즉, 최근의 서버 프로그램은 다양한 브라우저와 안드로이드 폰, 아이폰과 같은 모바일 디바이스에서도 통신을 할 수 있어야 한다.
  - REST 구성 요소
    - 자원(Resource) : URI
      - 모든 자원에 고유한 ID가 존재하고, 이 자원은 Server에 존재한다.
        - 자원을 구별하는 ID는 '/groups/:group_id'와 같은 HTTP URI 다.
        - 클라이언트는 URI를 이용해서 자원을 지정하고 해당 자원의 상태에 대한 조작을 Server에 요청한다.
    - 행위 : HTTP Method
      - HTTP 프로토콜의 메소드를 사용한다
      - HTTP 프로토콜은 GET, POST, PUT, DELETE, HEAD 와 같은 메소드를 제공한다.
    - 표현
      - 클라이언트가 자원의 상태에 대한 조작을 요청하면 Server는 이에 적절한 응답을 보낸다.
      - REST에서 하나의 자원은 JSON, XML, TEXT 등 여러 형태의 표현으로 나타내어 질 수 있다.
      - JSON 혹은 XML를 통해 데이터를 주고 받는 것이 가장 일반적이다.
  - REST의 특징
    - 서버-클라이언트 구조
    - 무샅애
    - 캐시 처리 가능
    - 계층화
    - 인터페이스 일관성



### Socket.io와 WebSocket의 차이

- WebSocket
  - 개념
    - 웹 페이지의 한계에서 벗어나 실시간으로 상호작용하는 웹 서비스를 만드는 표준 기술
  - 배경
    - HTTP 프로토콜은 클라이언트에서 서버로의 단방향 통신을 위해 만들어진 방법이다.
    - 실시간 웹을 구현하기 위해서는 양방향 통신이 가능해야 하는데, WebSocket 이전에는 Polling, Streaming 방식의 AJAX 코드를 이용하여 구현
    - 하지만 이 방법들을 이용하면 각 브라우저마다 구현 방법이 달라 개발이 어렵다는 문제점 발생
    - 이를 위해 HTML5 표준의 일부로 WebSocket이 만들어지게 되었다.
  - 일반 TCP Socket과의 차이점
    - 일반 HTTP Request를 통해 handshaking 과정을 거쳐 최초 접속이 이뤄진다.
  - 특징
    - 소켓을 이용하여 자유롭게 데이터를 주고 받을 수 있다.
    - 기존의 요청-응답 관계 방식보다 더 쉽게 데이터를 교환할 수 있다.
    - 다른 HTTP Request와 마찬가지로 80포트를 통해 웹 서버에 연결한다.
    - http::// 대신 ws:// 로 시작하며 Streaming과 유사한 방식으로 푸쉬를 지원한다.
    - 클라이언트인 브라우저와 마찬가지로 웹 서버도 WebSocket 기능을 지원해야 한다.
    - WebSocket은 다가올 미래의 기술이지 아직 인터넷 기업에서 시범적으로라도 써 볼 수 있는 기술이 아니다.
  - 장점
    - HTTP Request를 그대로 사용하기 때문에 기존의 80, 443 포트로 접속을 하므로 추가로 방화벽을 열지 않고도 양방향 통신이 가능하다.
- Socket.io
  - 개념
    - 다양한 방식의 실시간 웹 기술을 손쉽게 사용할 수 있는 모듈 (웹 클라이언트의 푸쉬를 지원하는 모듈)
    - 즉, Socket.io는 JavaScript를 이용하여 브라우저 종류에 상관없이 실시간 웹을 구현할 수 있도록 한 기술
  - 특징
    - Socket.io는 현재 바로 사용할 수 있는 기술이다.
    - WebSocket 프로토콜은 IETF에서 관장한은 표준 프로토콜이라서 WebSocket을 지원하는 여러 서버 구현체가 있지만 Socket.io는 Node.js 뿐이다.
  - 장점
    - WebSocket을 지원하지 않는 어느 브라우저라도 푸쉬 메세지를 일관된 모듈로 보낼 수 있다.



![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/osi-pdu.png)







# Operating System

## 프로세스와 스레드의 차이

- ### 프로그램이란

  - 어떤 작업을 위해 실행할 수 있는 파일

- ### 프로세스란

  - 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램

    - 메모리에 올라와 실행되고 있는 프로그램의 인스턴스 (독립적인 개체)
    - 운영체제로부터 시스템 자원을 할당받는 작업의 단위
    - 즉, 동적인 개념으로는 실행된 프로그램을 의미한다.

  - 할당받는 시스템 자원의 예

    - CPU 시간
    - 운영되기 위해 필요한 주소 공간
    - Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역

  - 특징

    ![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/process.png)

  - 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당받는다.

  - 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있다.

  - 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.

  - 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신 IPC(Inter-Process-Communicantion)을 사용해야 한다. (e.g) 파이프, 파일, 소켓 등을 이용한 통신 방법 이용)

- ### 스레드란

  - 프로세스 내에서 실행되는 여러 흐름의 단위

    - 프로세스의 특정한 수행 경로
    - 프로세스가 할당받은 자원을 이용하는 실행의 단위

  - 특징

    ![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/thread.png)

    - 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다.
    - 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들을 같은 프로세스 내에서 스레드끼리 공유하면서 실행된다.
    - 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유한다. 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.
    - 각각의 스레드는 별도의 레지스터와 스택을 갖고 있ㄷ지만, 힙 메모리는 서로 읽고 쓸 수 있다.
    - 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드도 그 변경 결과를 즉시 볼 수 있다.

  - ### 자바 스레드란

    - 일반 스레드와 거의 차이가 없으며, JVM가 운영체제의 역할을 한다.
    - 자바에는 프로세스가 존재하지 않고 스레드만 존재하며, 자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록이다.
    - 자바에서 스레드 스케줄링은 전적으로 JVM에 의해 이루어진다.
    - 아래와 같은 스레드와 관련된 많은 정보들도 JVM에 의해 이루어진다.
      - 스레드가 몇 개 존재하는지
      - 스레드로 실행되는 포그램의 코드의 메모리 위치는 어디인지
      - 스레드의 상태는 무엇인지
      - 스레드 우선순위는 얼마인지
    - 즉, 개발자는 자바 스레드로 작동할 스레드 코드를 작성하고, 스레드 코드가 생명을 가지고 실행을 시작하도록 JVM에 요청하는 일 뿐이다.

- ### 멀티 프로세스 대신 멀티 스레드를 사용하는 이유

  - 쉽게 설명하자면, 프로그램을 여러 개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이다.

    ![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/multi-thread.png)

  - 자원의 효율성 증대

    - 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
      - 프로세스 간의 Context Switching (문맥 교환)시 단순히 CPU 레지스터 교체 뿐만 아니라 RAM과 CPU 사이의 캐시 메모리에 대한 데이터까지 초기화되므로 오버헤드가 크기 떄문
    - 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소마가 줄어들게 된다.

  - 처리 비용 감소 및 응답 시간 단축

    - 또한 프로세스 간의 통신(IPC)보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신의 부담이 줄어든다.
      - 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문
    - 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다.
      - 문맥 교환시 스레드는 Stack 영역만 처리하기 때문

  - <span style = "color : red">주의할 점!</span>

    - 동기화 문제
    - 스레드 간의 자원 공유는 전역 변수(데이터 세그먼트)를 이용하므로 함께 상용할 때 충돌이 발생할 수 있다.

- ### Thread-safe

  - #### Thread-safe란?

    - 멀티스레드 환경에서 여러 스레드가 동시에 하나의 객체 및 변수(공유 자원)에 접근할 때, 의도한 대로 동작하는 것을 말한다.
    - 이러한 상황을 "Thread-safe"라고 표현한다.

  - #### Thread-safe하게 구현하기

    - Thread-safe하기 위해서는 공유 자원에 접근하는 임계영역(critical section)을 동기화 기법으로 제어해줘야 한다.
      - 이를 Mutual exclusion (상호배제)라고 한다.
    - 동기화 기법으로는 Mutex나 Semaphore 등이 있다.

  - #### Reentrant

    - 재진입성의 의미로, 어떤 함수가 Reentrant하다는 것은 여러 스레드가 동시에 접근해도 언제나 같은 실행 결과를 보장하는 의미이다.
    - 이를 만족하기 위해서 해당 서브루틴에서는 공유자원을 사용하지 않으면 된다.
    - Reentrant -> Thread-safe하다.

- ### 동기화 객체의 종류

  - #### 스레드 동기화 방법

    - 실행 순서의 동기화
      - 스레드의 실행순서를 정의하고, 이 순서에 반드시 따르도록 하는 것
    - 메모리 접근에 대한 동기화
      - 메모리 접근에 있어서 동시접근을 막는 것
      - 실행의 순서가 중요한 상황이 아니고, 한 순간에 하나의 스레드만 접근하면 되는 상황을 의미

  - #### 동기화 기법의 종류

    - 유저 모드 동기화
      - 커널의 힘을 빌리지 않는 동기화 기법
      - 성능상 이점, 기능상의 제한
      - e.g) 크리티컬 섹션 기반의 동기화, 인터락 함수 기반의 동기화
    - 커널 모드 동기화
      - 커널에서 제공하는 동기화 기능을 활용하는 방법
      - 커널 모드로의 변경이 필요하고 이는 성능 저하로 이어짐, 다양한 기능 활용 기능
      - e.g) 뮤텍스 기반의 동기화, 세마포어 기반의 동기화, 이름있는 뮤텍스 기반의 프로세스 동기화, 이벤드 기반의 동기화

- ### 뮤텍스와 세마포어의 차이

  - #### 뮤텍스

    - 공유된 자원의 데이터를 <b>여러 스레드</b>가 접근하는 것을 막는 것
    - 상호배제라고도 하며, Critical Section을 가진 스레드의 Running time이 서로 겹치지 않도록 각각 단독으로 실행하게 하는 기술이다.
    - 다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 synchronized 또는 Lock 을 사용한다
      - 즉, 뮤텍스 객체를 두 스레드가 동시에 사용할 수 없다.

  - #### 세마포어

    - 공유된 자원의 데이터를 <b>여러 프로세스</b>가 접근하는 것을 막는 것
    - 리소스 상태를 나타내는 간단한 카운터로 생각할 수 있다.
      - OS 또는 커널의 한 지정된 저장장치 내의 값이다.
      - 일반적으로 비교적 긴 시간을 확보하는 리소스에 대해 이용한다.
      - 유닉스 시스템 프로그래밍에서 세마포어는 운영체제의 리소스를 경쟁적으로 사용하는 다중 프로세스에서 행동을 조정하거나 또는 동기화 시키는 기술이다.
    - 공유 리소스에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자가 접근하여 사용할 수 있다.
    - 각 프로세스는 세마포어 값을 확인하고 변경할 수 있다.
      - 사용 중이지 않는 자원 경우 그 프로세스가 즉시 자원을 사용할 수 있다.
      - 이미 다른 프로세스에 의해 사용 중이라는 사실을 알게 되면 재시도하기 전에 일정 시간을 기다려야 한다.
      - 세마포어를 사용하는 프로세스는 그 값을 확인하고, 자원을 사용하는 동안에는 그 값을 변경함으로써 다른 세마포어 사용자들이 기다리도록 해야한다.
      - 세마포어는 이진수를 사용하거나, 추가적인 값을 가질 수 있다.

  - #### 차이

    - 가장 큰 차이점은 관리하는 동기화 대상의 개수
      - 뮤텍스는 동기화 대상이 오직 하나뿐일 때, 세마포어는 동기화 대상이 하나 이상일 때 사용한다.
    - 세마포어 -> 뮤텍스 (o) , 뮤텍스 -> 세마포어(x)
    - 세마포어는 소유할 수 없는 반면, 뮤텍스는 소유가 가능하며 소유주가 이에 대한 책임을 가진다.
      - 뮤텍스의 경우 상태가 두개 뿐인 lock 이므로 lock 을 가질 수 있다.
    - 뮤텍스의 경우 뮤텍스를 소유하고 있는 스레드가 이 해제할 수 있다. 하지만 세마포어의 경우 이러한 세마포어를 소유하지 않는 스레드가 세마포어를 해제할 수 있다.
    - 세마포어는 시스템 범위에 걸쳐있고 파일 시스템상의 파일 형태로 존재하는 반면, 뮤텍스는 프로세스 범위를 가지며 프로세스가 종료될 때 자동으로 Clean Up 된다.

- ### 동기와 비동기

  - #### 동기란?

    - 두개의 프로세스가 데이터를 주고 받을 때, 주고 받는 순서(또는 시간)가 일정하는 것을 뜻한다.

  - #### 비동기란?

    - 동기가 아닌 것

  - #### 동기식, 동기적이다

    - 어떤 작업을 요청했을 때 그 작업이 종료될 때까지 기다린 후 다음 작업을 수행한다.
      - 데이터를 주고받는 '순서'가 중요할 때 사용된다.
      - 요청한 작업만 처리하면 되기 때문에 전체적인 수행 속도는 빠를 수 있다.
      - 한 작업에 대한 시간이 길어질 경우, 전체 응답이 지연될 수 있다.

  - #### 비동기식, 비동기적이다.

    - 어떤 작업을 요청했을 때 그 작업이 종료될 때까지 기다리지 않고, 다음 작업을 수행한다. 요청했던 작업이 끝나면 결과를 받고, 그에 따른 추가 작업이 있다면 수행한다.
      - 요청 순서에 상관없이, 동시에 다수의 작업을 처리할 수 있다.
      - 작업이 끝날 떄 따로 이벤트를 감지하고 결과를 받아 그에 따른 추가 작업을 해줘야하기 때문에, 비교적 느릴 수 있다.
      - I/O 작업이 잦고, 빠른 응답속도를 요구하는 프로그램에 적합하다.

- ### 교착상태의 개념과 조건

  - #### 교착상태(데드락)?

    - 첫 번째 스레드는 두 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리고 있고, 두 번째 스레드 역시 첫 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리고 있는 상황을 일컷는다.
    - 모든 스레드가 락이 풀리기를 기다리고 있기 때문에, 무한 대기 상태에 빠지게 된다. 이런 스레드를 교착상태에 빠졌다고 한다.

  - #### 교착상태의 4가지 조건

    - ##### 상호배제

      - 한 번에 한 프로세스만 공유 자원을 사용할 수 있다.
      - 좀 더 정확하게는, 공유 자원에 대한 접근 권한이 제한된다. 자원의 양이 제한되어 있더라도 교착상태는 발생할 수 있다.

    - ##### 점유 대기

      - 공유 자원에 대한 접근 권한을 갖고 있는 프로세스가 그 접근 권한을 양보하지 않은 상태에서 다른 자원에 대한 접근 권한을 요구할 수 있다.

    - ##### 비선점

      - 한 프로세스가 다른 프로세스의 자원 접근 권한을 강제로 취소할 수 없다

    - ##### 순환대기

      - 두 개 이상의 프로세스가 자원 접근을 기다리는데, 그 관계에 사이클이 존재한다.

  - #### 교착상태 방지

    - 4가지 조건들 가운데 하나를 제거하면 된다.
    - 공유 자원 중 많은 경우가 한 번에 한 프로세스만 사용할 수 있기 때문에 상호배제는 제거하기 어렵다.
    - 대부분의 교착상태 방지 알고리즘은 4번 조건, 즉 대기 상태의 사이클이 발생하는 일을 막는데 초점이 맞춰져있다.

- ### Context Switching

  - #### Context Switching?

    - 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정을 말한다.

  - #### Context Switching 과정

    - Task의 대부분 정보는 레지스터에 저장되고 PCB로 관리된다.
    - 현재 실행되고 있는 Task의 PCB 정보를 저장하다. (Process Stack, Ready Queue)
    - 다음 실행할 Task의 PCB 정보를 읽어 레지스터에 적재하고, CPU가 이전에 진행했던 과정을 연속적으로 수행할 수 있다.

  - #### Context Switching Cost (Process vs Thread)

    - Process Context Switching 비용 > Thread Context Switching 비용
    - Thread는 Stack 영역을 제외한 모든 메모리를 공유하므로 Context Switching 수행 시 Stack 영역만 변경하면 되기 때문에 비용이 적게 든다.





















































































