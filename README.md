# Brand Experience

- 브랜드가 고객을 만나는 모든 활동, 경험
- Brand, Experience, Design을 하나라 통합한 의미
- 기업의 브랜드를 소비자들이 경험할 수 있도록 디자인하고 기획하는 것을 의미
- 조금 더 쉽게 설명하자면, 기업들은 고유의 브랜드를 가지고 있다. 소비자는 기업의 브랜드를 다양한 채널, 접점을 통하여 경험을 한다. 예를들어, 회사의 로고를 반복적으로 접하거나, 기업의 제품을 구매하기 위해 홈페이지에 들어가거나, 광고를 통해서 접할 수도 있다. -> 소비자는 기업을 경험할 수 있는 다양한 접점과 지속적으로 마주하게 됩니다.
- 기업에서 추구하는 브랜드의 목표와 가치를 다양한 미디어의 마케팅접점에서 사용자들에게 정확히 전달 할 수 있는 경험을 기획하고 이를 위한 최적을 디자인을 하는 것
- 브랜드 경험이 중요한 이유는 소비자들에게 호감과 애착을 형성하고, 그들이 기업이 바라는 대로 이끌 수 있다는 점
  - 소비자들은 기업이 표방하는 가치를 원하여 브랜드를 구매하게 된다.
- 최근의 추세는 브랜드 경험이라는 분야를 선호하는 상황. 기업의 고유한 가치를 소비자들도 인식하게 됌. 또한, 단지 '제품을 구매한다'는 측면에서 벗어나 소비자들이 기업이 추구하는 '가치를 구매한다'는 성향을 갖게 된 것. 가치를 구매하기 때문에 자신이 추구하는 가치와 부합되는 브랜드를 구매하고 선호하는 현상이 확산됨
- 브랜드 경험이 다양한 매체를 통해 이루어지기 때문에, 모든 매체에서 일관된 모습을 드러나야 한다. 하나의 방향성과 일관된 형태를 통해 소비자에게 혼란의 여지 없는 정확한 브랜드 경험을 심어줄 수 있다. 또한, 소비자 뿐만 아니라 기업 내부 직원들에게까지 일관된 브랜드 경험을 제공해주어, '하나의 브랜드 경험, 브랜드 가치'를 전달하는 것.





# Hash Table

## Hash Table 동작 과정

1. Key -> Hash Function -> 결과 = Hash
2. Hash를 배열의 Index로 사용
3. 해당 Index에 Value 저장



## Hash 충돌

1. 서로 다른 key가 Hash Function에서 중복 Hash로 나오는 경우
2. 충돌이 많아질수록 탐색의 시간 복잡도가 O(1)에서 O(n)으로 증가

### Hash 충돌 해결 방법

1. Seperating Chaining
   - JDK 내부에서 사용하는 충돌 처리 방식
   - Linked List로 Hash값이 같은 Value 값 연결
2. Open addressing
   - 추가 메모리 공간을 사용하지 않고, Hash Table 배열의 빈 공간을 사용하는 방법
3. Resizing
   - 저장 공간이 일정 수3준 채워지면 Seperating Chaining의 경우 성능 향상을 위해 Open addressing의 경우 배열 크기 확장을 위해 Resizing
   - 보토 2배로 확장



## Hash Table의 장점

1. 작은 리소스로 많은 데이터를 효율적으로 관리 가능
2. 배열의 인덱스를 사용하기 때문에 빠른 검색, 삽입, 삭제 O(1)
3. Key와 Hash에 연관성이 없어 보안에 유리
4. 중복 제거 유용

## Hash Table의 단점

1. 충돌 발생 가능성
2. 공간 복잡도 무시
3. 순서 무시
4. 해시 함수에 의존



## Hash Table vs Hash Map

- Hash Table
  - 비동기 (단일 스레드)에서 사용
  - null 값 허용
- Hash Map
  - 동기 (멀티 스레드)에서 사용
  - null 값 미허용





# Stack

- LIFO
- 재귀 알고리즘
- 웹 브라우저 방문기록
- 실행 취소
- 역순 문자열 만들기
- 수식의 괄호 검사 (VPS, Valid Parenthesis String)
- 후휘 표기법 검사

# Queue

- FIFO
- BFS 구현
- 캐시 구현
- 우선순위가 같은 작업 예약 (인쇄 대기열)
- 선입선출이 필요한 대기역 (티켓 카운터)
- 콜센터 고객 대기시간
- 프린터의 출력 처리
- 프로세스 관리



---



# Network

## OSI 7계층

- ISO에서 개발한 모델로, 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명
- 프로토콜을 기능별로 나눈 것

1. 물리 계층
   - 네트워크의 기본 네트워크 하드웨어 전송 기술을 이룬다.
   - 네크워크의 높은 수준의 기능의 논리 데이터 구조를 기초로 하는 필수 계층이다.
   - 전송 단위는 Bit이다.
2. 데이터 링크 계층
   - P2P 간 신뢰성 있는 전송을 보장하기 위한 계층으로 CRC 기반의 오류 제어와 흐름 제어가 필요하다.
   - 주소 값은 물리적으로 할당 받는데, 이는 네트워크 카드가 만들어질 때부터 맥 주소가 정해져 있다는 뜻이다.
   - 데이터 링크 계층의 대표적 예는 이더넷이다.
   - 전송 단위는 Frame이다.
3. 네트워크 계층
   - 여러개의 노드를 거칠때마다 경로를 찾아주는 역할 하는 계층으로 다양한 길이의 데이터를 네트워크들을 통해 전달하고, 그 과정에서 전송 계층이 요구하는 서비스 품질(QoS)를 제공하기 위한 기능적, 절차적 수단을 제공한다.
   - 네트워크 계층은 라우팅, 흐름 제어, 세그멘테이션, 오류 제어 등을 수행한다.
   - 논리적인 주소 구조(IP), 곧 네트워크 관리자가 직접 주소를 할당하는 구조를 가지며, 계층적이다.
   - 데이터 전송 단위는 Datagram(Packet)이다.
4. 전송 계층
   - E2E의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해 주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다.
   - 시퀀스 넘버 기반의 오류 제어 방식을 사용한다.
   - 전송 계층이 패킷들의 전송이 유효한지 확인하고 전송 실패한 패킷들을 다시 전송한다.
   - 가장 잘 알려진 전송 계층의 예는 TCP이다.
   - 전송 단위는 Segment이다.
5. 세션 계층
   - 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.
   - Duplex, half-duplex, full-duplex의 통신과 함께, 체크 포인팅과 유휴, 종료, 다시 시작 과정 등을 수행한다.
   - 이 계층은 TCP/IP 세션을 만들고 없애는 역할을 한다.
6. 표현 계층
   - 코드 간의 번역을 담당, 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어 준다.
   - 인코딩이나 암호화 등의 동작이 이 계층에서 이루어진다.
7. 응용 계층
   - 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.



## TCP와 UDP

- 네트워크 계층 중 전송 계층에서 사용하는 프로토콜

### TCP

- 인터넷 상에서 데이터를 메세지의 형태(세그먼트 라는 블록 단위)로 보내기 위해 IP와 함께 사용하는 프로토콜이다.
- TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리한다.
- 연결형 서비스로 가상 회선 방식을 제공한다.
  - 3-way handshaking 과정을 통해 연결을 설정하고, 4-way handshaking을 통해 연결을 해제한다.
- 흐름 제어 및 혼잡제어를 제공한다.
  - 흐름제어
    - 데이터를 보내는 곳과 받는 곳의 데이터 처리 속도를 조절하여 받는 곳의 버퍼 오버플로우를 방지하는 것
  - 혼잡제어
    - 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것
    - 정보의 소통량이 과다하면 패킷을 조금만 전송하여 혼잡 붕괴 현상이 일어나는 것을 막는다.
  - 높은 신뢰성을 보장한다.
  - UDP보다 속도가 느리다.
  - Full-Duplex, Point-to-Point 방식이다.
    - Full-Duplex
      - 전송이 양방향으로 동시에 일어날 수 있다.
    - Point-to-Point
      - 각 연결이 정확히 2개의 종단점을 가지고 있다.
    - 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.
  - 연속성보다 신뢰성 있는 전송이 중요할 때 사용

### UDP

- 데이터를 데이터 그램 단위로 처리하는 프로토콜이다.
- 비연결형 서비스로 데이터그램 방식을 제공한다.
  - 연결을 위해 할당되는 논리적인 경로가 없다.
  - 따라서, 각각의 패킷은 다른 경로로 전송되고, 각각의 패킷은 독릭접인 관계를 갖게 된다.
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
- UDP헤더에서 checksum 필드를 통해 최소한의 오류만 검출한다.
- 신뢰성이 낮다.
- TCP보다 속도가 빠르다.
- 신뢰성보다는 연속성이 중요한 서비스, 스트리밍에 사용된다.

### 참고

- UDP와 TCP는 각각 별도의 포트 주소 공간을 관리하므로 같은 포트 번호를 사용해도 무방하다. 즉, 두 프로토콜에서 동일한 포트 번호를 할당해도 서로 다른 포트로 간주한다.



### TCP의 3 way handshake 와 4 way handshake

- TCP는 장치들 사이에 논리적인 접ㅂ속을 성립하기 위하여 연결을 설정하여 신뢰성을 보장하는 연결형 서비스이다.

#### 3 way handshake

- TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정
- 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장, 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었다는 것을 알 수 있게 해준다.
- 즉, TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.
  - A 프로세스(Client)가 B 프로세스(Server)에 연결을 요청![3-way-handshaking](/Users/ryuseungmin/Desktop/dev사진/3-way-handshaking.png)
    - A -> B : SYN
      - 접속 요청 프로세스 A가 연결 요청 메시지 전송 (SYN)
      - 송신자가 최초로 데이터를 전송할 때 Sequence Number를 임의 랜덤 숫자로 지정하고, SYN 플래그 비트를 1로 설정한 세그먼트를 전송한다.
    - B -> A : SYN + ACK
      - 접속 요청을 받은 프로세스 B가 요청을 수락했으며, 접속 요청 프로세스인 A도 포트를 열어 달라는 메시지 전송 (SYN + ACK)
      - 수신자는 ACK# 필드를 Sequence# + 1로 지정하고, SYN과 ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
    - A -> B : ACK
      - 마지막으로 접속 요청 프로세스 A가 수량 확인을 보낸 연결을 맺음 (ACK)
      - 이때, 전송할 데이터가 있으면 이 단계에서 데이터를 전송할 수 있다.

#### 4 way handshake

- TCP의 연결을 해체하는 과정

  - A 프로세스(Client)가 B 프로세스(Server)에 연결 해제를 요청

    ![4-way-handshaking](/Users/ryuseungmin/Desktop/dev사진/4-way-handshaking.png)

  - A -> B: FIN

    - 프로세스 A가 연결을 종료하겠다는 FIN 플래그를 전송
    - 프로세스 B가 FIN 플래그로 응답하기 전까지 연결을 계속 유지

  - B -> A : ACK

    - 프로세스 B는 일단 확인 메시지를 보내고 자신의 통신이 끝날 때까지 기다린다.
    - 수신자는 ACK$ 필드를 Seq# + 1로 지정하고, ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
    - 그리고 자신이 전송할 데이터가 남아있다면 이어서 계속 전송한다.

  - B -> A : FIN

    - 프로세스 B가 통신이 끝났으면 연결 종료 요청에 합의한다는 의미로 프로세스 A에게 FIN 플래그를 전송

  - A -> B : ACK

    - 프로세스 A는 확인했다는 메시지를 전송

  #### TCP 관련 질문

  - TCP의 연결 설정 과정과 연결 종료 과정이 단계가 차이나는 이유?
    - 클라이언트가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 떄문이다.
  - 만약 서버에서 FIN 플래그를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?
    - 이러한 현상에 대비하여 클라이언트는 서버로부터 FIN 플래그를 수신하더라도 일정 시간동안 세션을 남겨 놓고 잉여 패킷을 기다리는 과정을 거친다.
  - 초기 Seq# 인 ISN을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유는?
    - 연결을 맺을 때 사용하는 포트는 유한 범위 내에서 사용하고, 시간이 지남에 따라 재사용 된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다. 서버 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 #가 전송된다면 이전의 연결로부터 오는 패킷으로 인식할 수 이있다. 이런 문제가 발생할 가능성을 줄이기 위해 난수를 설정한다.



### HTTP와 HTTPS

- HTTP 프로토콜
  - 개념
    - HyperText Transfer Protocol
    - 웹 상에서 클라이언트와 서버 간에 요청/응답으로 정보를 주고 받을 수 있는 프로토콜
  - 특징
    - 주로 HTML 문서를 주고 받는 데에 쓰인다.
    - TCP와 UDP를 사용하며, 80번 포트를 사용.
    - 비연결
      - 클라이언트가 요청을 서버에 보내고 서버가 적절한 응답을 클라이언트에 보내면 바로 연결이 끊긴다.
    - 무상태
      - 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다.
- HTTPS 프로토콜
  - 개념
    - HTTP over TLS, HTTP over SSL, HTTP Secure
    - 웹 통신 프로토콜인 HTTP의 보안이 강화된 버전의 프로토콜
  - 특징
    - HTTPS의 기본 TCP/IP 포트로 443번 포트를 사용한다.
    - HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에, 웹 상에서 정보를 암호화하는 SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화한다.
      - TLS(Transport Layer security) 프로토콜은 SSL(Secure Socket Layer) 프로토콜에서 발전한 것이다.
      - 두 프로토콜의 주요 목표는 기밀성, 데이터 무결성, ID 및 디지털 인증서를 사용한 인증을 제공하는 것이다.
    - 따라서 데이터의 적절한 보호를 보장한다.
      - 보호의 수준은 웹 브라우저에서의 구현 정확도와 서버 소프트웨어, 지원하는 암호화 알고리즘에 달려있다.
    - 금융 정보나 메일 등 중요한 정보를 주고받는 것은 HTTPS를, 아무나 봐도 상관없는 페이지는 HTTP를 사용한다.
- HTTPS가 필요한 이유
  - 클라이언트인 웹브라우저가 서버에 HTTP를 통해 웹 페이지나 이미 정보를 요청하면 서버는 이 요청에 응답하여 요구하는 정보를 제공하게 된다.
  - 웹 페이지(HTML)는 텍스트이고, HTTP를 통해 이런 텍스트 정보를 교환하는 것이다.
  - 이때 주고받는 텍스트 정보에 주번이나 비번과 같이 민감한 정보가 포함된 상태에서 네트워크 상에서 중간에 제 3자가 정보를 가로챈다면 보안상 큰 문제가 발생한다.
  - 즉, 중간에서 정보를 볼 수 없도록 주고받는 정보를 암호화하는 방법인 HTTPS를 사용하는 것이다.
- HTTPS의 원리
  - 공개키 알고리즘 방 (비대칭키 암호화 방식)
    - 공개키와 개인키를 이용한 암호화 방식
  - 암호화, 복호화시킬 수 있는 서로 다른 키를 이용한 방법
    - 공개키 : 모두에게 공개, 공개키 저장소에 등록
    - 개인키 : 개인에게만 공개, 클라이언트-서버 구조에서는 서버가 가지고 있는 비공개키
  - 클라이언트 -> 서버
    - 사용자의 데이터를 공개키로 암호화 (공개키를 얻은 인증된 사용자)
    - 서버로 전송 (데이터를 가로채도 개인키가 없으므로 복호화할 수 없음)
    - 서버의 개인키를 통해 복호화하여 요청 처리
- HTTPS의 장단점
  - 장점
    - 네트워크 상에서 열람, 수정이 불가능하므로 안전하다.
  - 단점
    - 암호화를 하는 과정이 웹 서버에 부하를 준다.
    - HTTPS는 설치 및 인증서를 유지하는데 추가 비용이 발생한다.
    - HTTP에 비해 느리다.
    - 인터넷 연결이 끊긴 경우 재인증 시간이 소요된다.
      - HTTP는 비연결형으로 웹 페이지를 보는 중 인터넷 연결이 끊겼다가 다시 연결되어도 페이지를 계속 볼 수 있다.
      - 그러나 HTTPS의 경우에는 소켓(데이터를 주고 받는 경로) 자체에서 인증을 하기 때문에 인터넷 연결이 끊기면 소켓도 끊어져서 다시 HTTPS 인증이 필요하다.



### GET & POST

- HTTP 프로토콜을 이용해서 서버에 데이터를 전달할 때 사용하는 방식
- GET 방식
  - 개념
    - 정보를 조회하기 위한 메소드
    - 서버에서 어떤 데이터를 가져와서 보여주기 위한 용도의 메소드
    - 가져오는 것(Select)
  - 사용 방법
    - URL의 끝에 '?' 가 붙고, 요청 정보가 (key=value) 형태의 쌍을 이루어 ?뒤에 이어서 붙어 서버로 전송한다.
    - 전송하는 정보가 여러개일 경우에는 &로 구분한다.
    - e.g.) www.server.com?name1=value1&name2=value2
  - 특징
    - URL에 요청 정보를 붙여서 전송한다.
    - URL에 요청 정보가 이어붙기 때문에 길이 제한이 있어서 대용량의 데이터를 전송하기 어렵다.
    - 요청 정보를 사용자가 쉽게 눈으로 확인 가능하다.
    - HTTP 패킷의 Body는 비어 있는 상태로 전송한다.
    - POST 방식보다 빠르다.
      - GET 방식은 캐싱을 사용할 수 있어, GET 요청과 그에 대한 응답이 브라우저에 의해 캐쉬된다.
- POST 방식
  - 개념
    - 서버의 값이나 상태를 바꾸기 위한 용도의 메소드
    - 수행하는 것(Insert, Update, Delete)
  - 사용 방법
    - 요청 정보를 HTTP 패킷의 Body 안에 숨겨서 서버로 전송한다.
  - 특징
    - Body 안에 숨겨서 요청 정보를 전송하기 때문에 대용량의 데이터를 전송하기에 적합하다.
    - 클라이언트 쪽에서 데이터를 인코딩하여 서버로 전송하고, 이를 받은 서버 쪽이 해당 데이터를 디코딩한다.
    - GET 방식보다 보안상 안전하다.
- POST/GET 질문
  - 조회하기 위한 용도 POST가 아닌 GET 방식을 사용하는 이유?
    - 설계 원칙에 따라 GET 방식은 서버에게 여러 번 요청을 하더라도 동일한 응답이 돌아와야 한다.
      - GET 방식은 가져오는 것(Select)으로 서버의 데이터나 상태를 변경시키지 않아야 한다.
        - e.g.) 게시판 리스트, 글 보기
      - POST 방식은 수행하는 것으로, 서버의 값이나 상태를 바꾸기 위한 용도이다.
        - e.g.) 게시판에 글쓰기 기능
    - 웹에서 모든 리소스는 Link 할 수 있는 URL을 가지고 있어야한다.
      - 어떤 웹페이지를 보고 있을 때 다른 사람한테 그 주소를 주기 위해서 주소창의 URL을 복사해서 줄 수 있어야 한다.
      - 즉, 어떤 웹페이지를 조회할 때 원하는 페이지로 바로 이동하거나 이동시키기 위해서는 해당 링크의 정보가 필요하다.
      - 이때 POST 방식을 사용할 경우에 값(링크의 정보)이 Body에 있기 때문에 URL만 전달할 수 없으므로 GET 방식을 사용해야 한다. 그러나 글을 저장하는 경우에는 URL을 제공할 필요가 없기 때문에 POST 방식을 사용한다.



### 쿠키와 세션

- HTTP 프로토콜의 특징

  - 비연결 지향 
    - 클라이언트가 request를 서버에 보내고, 서버가 클라이언트에 요청에 맞는 response르 보내면 바로 연결을 끊는다.
  - 상태정보를 유지 안함
    - 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다.

- 쿠키와 세션의 필요성

  - HTTP 프로토콜은 위와 같은 특징으로 모든 요청 간 의존관계가 없다.
  - 즉, 현재 접속한 사용자가 이전에 접속했던 사용자와 같은 사용자인지 아닌지 알 수 있는 방법이 없다.
  - 계속해서 연결을 유지하지 않기 때문에 리소스 낭비가 줄어드는 것이 큰 장점이지만, 통신할 때마다 새로 연결하기 때문에 클라이언트는 매 요청마다 인증을 해야 한다는 단점이 있다.
  - 이전 요청과 현재 요청이 같은 사용자의 요청인지 알기 위해서는 상태를 유지해야 한다.
  - HTTP 프로토콜에서 상태를 유지하기 위한 기술로 쿠키와 세션이 있다.

- 쿠키(Cookie)란?

  - 개념

    - 클라이언트 로컬에 저장되는 키와 값이 들어있는 파일이다.
    - 이름, 값, 유효 시간, 경로 등을 포함하고 있다.
    - 클라리언트의 상태 정보를 브라우저에 저장하여 참조한다.

  - 동작 방식

    ![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/cookie-process.png)

    

    - 웹 브라우저가 서버에 요청
    - 상태를 유지하고 싶은 값을 쿠키로 생성
    - 서버가 응답할 때 HTTP 헤더에 쿠키를 포함해서 전송
    - 전달받은 쿠키는 웹브라우저에서 관리하고 있다가, 다음 요청 떄 쿠키를 HTTP 헤더에 넣어서 전송
    - 서버에서는 쿠키 정보를 읽어 이전 상태 정보를 확인하 후 응답

- 세션이란?

  - 개념

    - 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술이다.
    - 즉, 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태이다.

  - 동작 방식

    ![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/session-process.png)

    - 웹 브라우저가 서버에 요청
    - 서버가 해당 웹브라우저에 유일한 ID를 부여함
    - 서버가 응답할 때 HTTP 헤더에 세션 ID를 포함해서 전송, 쿠키에 세션 ID를 저장
    - 웹브라우저는 이후 웹브라우저를 닫기까지 다음 요청 때 부여된 세션 ID가 담겨있는 쿠키를 HTTP 헤더에 넣어서 전송
    - 서버는 세션 ID를 확인하고, 해당 세션에 관련된 정보를 확인한 후 응답

  - 세션 사용 예

    - 로그인

  - 세션도 쿠키를 사용하여 값을 주고받으며 클라이언트의 상태 정보를 유지한다. 즉, 상태 정보를 유지하는 수단은 쿠키 이다.

- 쿠키와 세션의 차이점

  - 저장 위치
    - 쿠키 : 클라이언트
    - 세션 : 서버
  - 보안
    - 쿠키 : 클라이언트에 저장되므로 보안에 취약하다.
    - 세션 : 쿠키를 이용해 세션 ID 만 저장하고 이 값으로 구분해서 서버에서 처리하므로 비교적 보안성이 좋다.
  - 라이프사이클
    - 쿠키 : 만료시간에 따라 브라우저를 종료해도 계속해서 남아 있을 수 있다.
    - 세션 : 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.
  - 속도
    - 쿠키 : 클라이언트에 저장되어서 서버에 요청 시 빠르다.
    - 세션 : 실제 저장된 정보가 서버에 있으므로 서버의 처리가 필요해 쿠키보다 느리다.







### REST와 RESTful의 개념

- REST란
  - REST의 정의
    - Representational State Transfer
    - www과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 개발 아키텍처의 한 형식
      - REST는 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일이다.
      - REST는 네트워크 상에서 클라이언트와 서버 사이의 통신 방식 중 하나이다.
  - REST의 구체적인 개념
    - HTTP URI(Uniform Resource Identifier)를 통해 자원을 명시하고, HTTP Method(Post, Get, Put, Delete)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.
      - 즉, REST는 자원 기반의 구조(ROA, Resource Oriented Architecture) 설계 중심에 Resource가 있고, HTTP 메소드를 통해 Resource를 처리하도록 설계된 아키텍처를 의미한다.
      - 웹 사이트의 이미지, 텍스트, DB 내용 등의 모든 자원에 고유한 ID인 HTTP URI를 부여한다.
  - REST 장단점
    - 장점
      - 여러 가지 서비스 디자인에서 생길 수 있는 문제를 최소화해준다.
      - Hypermedia API의 기본을 충실히 지키면서 범용성을 보장한다.
      - HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 해준다.
    - 단점
      - 브라우저를 통해 테스트할 일이 많은 서비스라면 쉽게 고칠 수 있는 URL보다 Header 값이 왠지 더 어렵게 느껴진다.
      - 구형 브라우저가 아직 제대로 지원해주지 못하는 부분이 존재한다.
        - PUT, DELETE를 사용하지 못하는 점
        - pushState를 지원하지 않는 점
  - REST가 필요한 이유
    - '애플리케이션 분리 및 통합'
    - '다양한 클라이언트의 등장'
    - 즉, 최근의 서버 프로그램은 다양한 브라우저와 안드로이드 폰, 아이폰과 같은 모바일 디바이스에서도 통신을 할 수 있어야 한다.
  - REST 구성 요소
    - 자원(Resource) : URI
      - 모든 자원에 고유한 ID가 존재하고, 이 자원은 Server에 존재한다.
        - 자원을 구별하는 ID는 '/groups/:group_id'와 같은 HTTP URI 다.
        - 클라이언트는 URI를 이용해서 자원을 지정하고 해당 자원의 상태에 대한 조작을 Server에 요청한다.
    - 행위 : HTTP Method
      - HTTP 프로토콜의 메소드를 사용한다
      - HTTP 프로토콜은 GET, POST, PUT, DELETE, HEAD 와 같은 메소드를 제공한다.
    - 표현
      - 클라이언트가 자원의 상태에 대한 조작을 요청하면 Server는 이에 적절한 응답을 보낸다.
      - REST에서 하나의 자원은 JSON, XML, TEXT 등 여러 형태의 표현으로 나타내어 질 수 있다.
      - JSON 혹은 XML를 통해 데이터를 주고 받는 것이 가장 일반적이다.
  - REST의 특징
    - 서버-클라이언트 구조
    - 무샅애
    - 캐시 처리 가능
    - 계층화
    - 인터페이스 일관성



### Socket.io와 WebSocket의 차이

- WebSocket
  - 개념
    - 웹 페이지의 한계에서 벗어나 실시간으로 상호작용하는 웹 서비스를 만드는 표준 기술
  - 배경
    - HTTP 프로토콜은 클라이언트에서 서버로의 단방향 통신을 위해 만들어진 방법이다.
    - 실시간 웹을 구현하기 위해서는 양방향 통신이 가능해야 하는데, WebSocket 이전에는 Polling, Streaming 방식의 AJAX 코드를 이용하여 구현
    - 하지만 이 방법들을 이용하면 각 브라우저마다 구현 방법이 달라 개발이 어렵다는 문제점 발생
    - 이를 위해 HTML5 표준의 일부로 WebSocket이 만들어지게 되었다.
  - 일반 TCP Socket과의 차이점
    - 일반 HTTP Request를 통해 handshaking 과정을 거쳐 최초 접속이 이뤄진다.
  - 특징
    - 소켓을 이용하여 자유롭게 데이터를 주고 받을 수 있다.
    - 기존의 요청-응답 관계 방식보다 더 쉽게 데이터를 교환할 수 있다.
    - 다른 HTTP Request와 마찬가지로 80포트를 통해 웹 서버에 연결한다.
    - http::// 대신 ws:// 로 시작하며 Streaming과 유사한 방식으로 푸쉬를 지원한다.
    - 클라이언트인 브라우저와 마찬가지로 웹 서버도 WebSocket 기능을 지원해야 한다.
    - WebSocket은 다가올 미래의 기술이지 아직 인터넷 기업에서 시범적으로라도 써 볼 수 있는 기술이 아니다.
  - 장점
    - HTTP Request를 그대로 사용하기 때문에 기존의 80, 443 포트로 접속을 하므로 추가로 방화벽을 열지 않고도 양방향 통신이 가능하다.
- Socket.io
  - 개념
    - 다양한 방식의 실시간 웹 기술을 손쉽게 사용할 수 있는 모듈 (웹 클라이언트의 푸쉬를 지원하는 모듈)
    - 즉, Socket.io는 JavaScript를 이용하여 브라우저 종류에 상관없이 실시간 웹을 구현할 수 있도록 한 기술
  - 특징
    - Socket.io는 현재 바로 사용할 수 있는 기술이다.
    - WebSocket 프로토콜은 IETF에서 관장한은 표준 프로토콜이라서 WebSocket을 지원하는 여러 서버 구현체가 있지만 Socket.io는 Node.js 뿐이다.
  - 장점
    - WebSocket을 지원하지 않는 어느 브라우저라도 푸쉬 메세지를 일관된 모듈로 보낼 수 있다.



![](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/osi-pdu.png)

































































































